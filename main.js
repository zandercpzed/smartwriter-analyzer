/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SmartWriterPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/types/index.ts
var DEFAULT_SETTINGS = {
  llmProvider: "ollama",
  ollamaEndpoint: "http://localhost:11434",
  ollamaModel: "llama3.1",
  claudeApiKey: "",
  claudeModel: "claude-sonnet-4-20250514",
  openaiApiKey: "",
  openaiModel: "gpt-4o",
  chunkSize: 1e4,
  maxContextTokens: 1e5,
  cacheDurationDays: 30,
  language: "pt-BR",
  enableABNTFormatting: false,
  enableAIDetection: true,
  autoSaveReports: true,
  reportOutputFolder: "SmartWriter Reports"
};

// src/core/cache-manager.ts
var CACHE_KEY = "smartwriter-cache";
var CacheManager = class {
  constructor(plugin) {
    this.cache = /* @__PURE__ */ new Map();
    this.loaded = false;
    this.plugin = plugin;
    this.loadCache();
  }
  async loadCache() {
    try {
      const data = await this.plugin.loadData();
      if (data && data[CACHE_KEY]) {
        const cacheData = data[CACHE_KEY];
        this.cache = new Map(Object.entries(cacheData));
        this.cleanExpiredEntries();
      }
      this.loaded = true;
    } catch (error) {
      console.error("Failed to load cache:", error);
      this.loaded = true;
    }
  }
  async saveCache() {
    try {
      const currentData = await this.plugin.loadData() || {};
      currentData[CACHE_KEY] = Object.fromEntries(this.cache);
      await this.plugin.saveData(currentData);
    } catch (error) {
      console.error("Failed to save cache:", error);
    }
  }
  /**
   * Gets cached analysis.
   */
  get(manuscriptPath, analysisType, contentHash) {
    const cache = this.cache.get(manuscriptPath);
    if (!cache) {
      return null;
    }
    const entry = cache.entries[analysisType];
    if (!entry || entry.manuscriptHash !== contentHash) {
      return null;
    }
    if (Date.now() > entry.expiresAt) {
      delete cache.entries[analysisType];
      this.saveCache();
      return null;
    }
    return entry.data;
  }
  /**
   * Stores analysis result in cache.
   */
  async set(manuscriptPath, analysisType, contentHash, data, ttlDays = 30) {
    const now = Date.now();
    const expiresAt = now + ttlDays * 24 * 60 * 60 * 1e3;
    let cache = this.cache.get(manuscriptPath);
    if (!cache) {
      cache = {
        manuscriptHash: "",
        // Deprecated in favor of per-entry hash
        entries: {}
      };
    }
    cache.entries[analysisType] = {
      key: analysisType,
      timestamp: now,
      expiresAt,
      data,
      manuscriptHash: contentHash
      // Re-using this field for content hash
    };
    this.cache.set(manuscriptPath, cache);
    await this.saveCache();
  }
  /**
   * Generates a hash for content.
   */
  hashContent(content) {
    let hash = 5381;
    for (let i = 0; i < content.length; i++) {
      hash = (hash << 5) + hash + content.charCodeAt(i);
      hash = hash & hash;
    }
    return hash.toString(16);
  }
  /**
   * Invalidates cache for a specific manuscript.
   */
  async invalidate(manuscriptPath) {
    this.cache.delete(manuscriptPath);
    await this.saveCache();
  }
  /**
   * Invalidates specific analysis type for a manuscript.
   */
  async invalidateAnalysis(manuscriptPath, analysisType) {
    const cache = this.cache.get(manuscriptPath);
    if (cache && cache.entries[analysisType]) {
      delete cache.entries[analysisType];
      await this.saveCache();
    }
  }
  /**
   * Clears all cached data.
   */
  async clearAll() {
    this.cache.clear();
    await this.saveCache();
  }
  /**
   * Gets cache statistics.
   */
  getStats() {
    let totalEntries = 0;
    let estimatedSize = 0;
    for (const cache of this.cache.values()) {
      totalEntries += Object.keys(cache.entries).length;
      estimatedSize += JSON.stringify(cache).length;
    }
    return {
      manuscripts: this.cache.size,
      entries: totalEntries,
      size: this.formatBytes(estimatedSize)
    };
  }
  formatBytes(bytes) {
    if (bytes < 1024)
      return bytes + " B";
    if (bytes < 1024 * 1024)
      return (bytes / 1024).toFixed(1) + " KB";
    return (bytes / (1024 * 1024)).toFixed(1) + " MB";
  }
  /**
   * Removes expired entries from cache.
   */
  cleanExpiredEntries() {
    const now = Date.now();
    let cleaned = false;
    for (const [path, cache] of this.cache.entries()) {
      for (const [type, entry] of Object.entries(cache.entries)) {
        if (now > entry.expiresAt) {
          delete cache.entries[type];
          cleaned = true;
        }
      }
      if (Object.keys(cache.entries).length === 0) {
        this.cache.delete(path);
        cleaned = true;
      }
    }
    if (cleaned) {
      this.saveCache();
    }
  }
  /**
   * Checks if analysis is cached and valid.
   */
  has(manuscriptPath, analysisType, contentHash) {
    return this.get(manuscriptPath, analysisType, contentHash) !== null;
  }
  /**
   * Gets all cached analysis types for a manuscript that match the current content hash.
   */
  getCachedTypes(manuscriptPath, contentHash) {
    const cache = this.cache.get(manuscriptPath);
    if (!cache) {
      return [];
    }
    const now = Date.now();
    return Object.entries(cache.entries).filter(([_, entry]) => now <= entry.expiresAt && entry.manuscriptHash === contentHash).map(([type, _]) => type);
  }
};

// src/llm/llm-service.ts
var import_obsidian = require("obsidian");
var LLMService = class {
  constructor(settings) {
    this.settings = settings;
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  async complete(request) {
    const maxRetries = 3;
    let lastError = null;
    for (let i = 0; i < maxRetries; i++) {
      try {
        switch (this.settings.llmProvider) {
          case "ollama":
            return await this.completeOllama(request);
          case "claude":
            return await this.completeClaude(request);
          case "openai":
            return await this.completeOpenAI(request);
          default:
            throw new Error(`Unknown LLM provider: ${this.settings.llmProvider}`);
        }
      } catch (error) {
        lastError = error;
        console.warn(`LLM request attempt ${i + 1} failed:`, error);
        if (this.isNonRetriableError(error)) {
          throw error;
        }
        if (i < maxRetries - 1) {
          const delay = Math.pow(2, i) * 1e3;
          await new Promise((resolve) => setTimeout(resolve, delay));
        }
      }
    }
    throw lastError || new Error("LLM request failed after retries");
  }
  isNonRetriableError(error) {
    if (error.status) {
      const status = error.status;
      return status >= 400 && status < 500 && status !== 429;
    }
    return false;
  }
  async testConnection() {
    try {
      const response = await this.complete({
        prompt: 'Say "OK" if you can read this.',
        maxTokens: 10
      });
      return response.content.toLowerCase().includes("ok");
    } catch (error) {
      console.error("LLM connection test failed:", error);
      return false;
    }
  }
  async completeOllama(request) {
    const endpoint = `${this.settings.ollamaEndpoint}/api/generate`;
    const body = {
      model: this.settings.ollamaModel,
      prompt: request.prompt,
      system: request.systemPrompt || "",
      stream: false,
      options: {
        num_predict: request.maxTokens || 4096,
        temperature: request.temperature || 0.7
      }
    };
    const response = await (0, import_obsidian.requestUrl)({
      url: endpoint,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });
    const data = response.json;
    return {
      content: data.response,
      tokensUsed: data.eval_count || 0,
      model: this.settings.ollamaModel,
      finishReason: data.done ? "stop" : "unknown"
    };
  }
  async completeClaude(request) {
    var _a, _b;
    const endpoint = "https://api.anthropic.com/v1/messages";
    const messages = [
      { role: "user", content: request.prompt }
    ];
    const body = {
      model: this.settings.claudeModel,
      max_tokens: request.maxTokens || 4096,
      messages
    };
    if (request.systemPrompt) {
      body.system = request.systemPrompt;
    }
    const response = await (0, import_obsidian.requestUrl)({
      url: endpoint,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": this.settings.claudeApiKey,
        "anthropic-version": "2023-06-01"
      },
      body: JSON.stringify(body)
    });
    const data = response.json;
    return {
      content: data.content[0].text,
      tokensUsed: ((_a = data.usage) == null ? void 0 : _a.input_tokens) + ((_b = data.usage) == null ? void 0 : _b.output_tokens) || 0,
      model: this.settings.claudeModel,
      finishReason: data.stop_reason || "unknown"
    };
  }
  async completeOpenAI(request) {
    var _a;
    const endpoint = "https://api.openai.com/v1/chat/completions";
    const messages = [];
    if (request.systemPrompt) {
      messages.push({ role: "system", content: request.systemPrompt });
    }
    messages.push({ role: "user", content: request.prompt });
    const body = {
      model: this.settings.openaiModel,
      messages,
      max_tokens: request.maxTokens || 4096,
      temperature: request.temperature || 0.7
    };
    const response = await (0, import_obsidian.requestUrl)({
      url: endpoint,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${this.settings.openaiApiKey}`
      },
      body: JSON.stringify(body)
    });
    const data = response.json;
    return {
      content: data.choices[0].message.content,
      tokensUsed: ((_a = data.usage) == null ? void 0 : _a.total_tokens) || 0,
      model: this.settings.openaiModel,
      finishReason: data.choices[0].finish_reason || "unknown"
    };
  }
  // Batch processing for large manuscripts
  async completeBatch(requests, concurrency = 3, onProgress) {
    const results = [];
    const queue = [...requests];
    let completed = 0;
    const processNext = async () => {
      while (queue.length > 0) {
        const request = queue.shift();
        if (!request)
          break;
        try {
          const result = await this.complete(request);
          results.push(result);
          completed++;
          onProgress == null ? void 0 : onProgress(completed, requests.length);
        } catch (error) {
          console.error("Batch request failed:", error);
          results.push({
            content: "",
            tokensUsed: 0,
            model: "",
            finishReason: "error"
          });
          completed++;
          onProgress == null ? void 0 : onProgress(completed, requests.length);
        }
      }
    };
    const workers = Array(Math.min(concurrency, requests.length)).fill(null).map(() => processNext());
    await Promise.all(workers);
    return results;
  }
};

// src/parsers/manuscript-parser.ts
var _ManuscriptParser = class _ManuscriptParser {
  parse(content, fileName) {
    const { frontMatter, body } = this.extractFrontMatter(content);
    const chapters = this.parseChapters(body);
    const totalWords = this.countWords(body);
    const totalParagraphs = this.countParagraphs(body);
    const totalSentences = this.countSentences(body);
    return {
      title: this.extractTitle(frontMatter, fileName),
      chapters,
      totalWords,
      totalParagraphs,
      totalSentences,
      metadata: {
        frontMatter,
        hasTableOfContents: this.detectTableOfContents(body),
        estimatedReadingTime: Math.ceil(totalWords / 200)
        // ~200 wpm reading speed
      }
    };
  }
  extractFrontMatter(content) {
    const frontMatterRegex = /^---\s*\n([\s\S]*?)\n---\s*\n/;
    const match = content.match(frontMatterRegex);
    if (!match) {
      return { frontMatter: {}, body: content };
    }
    try {
      const frontMatter = {};
      const lines = match[1].split("\n");
      for (const line of lines) {
        const colonIndex = line.indexOf(":");
        if (colonIndex > 0) {
          const key = line.substring(0, colonIndex).trim();
          const value = line.substring(colonIndex + 1).trim();
          frontMatter[key] = value;
        }
      }
      return {
        frontMatter,
        body: content.substring(match[0].length)
      };
    } catch (e) {
      return { frontMatter: {}, body: content };
    }
  }
  parseChapters(content) {
    const chapters = [];
    const chapterHeadingRegex = /^(?:#{1,2}\s+(?:Capítulo|Chapter|Cap\.?)\s*\d+|#{1,2}\s+\d+\s*[-–—:.]?\s*.+|(?:Capítulo|Chapter|Cap\.?)\s*\d+|#{1,2}\s+.+)$/gim;
    let match;
    let lastIndex = 0;
    let chapterIndex = 0;
    while ((match = chapterHeadingRegex.exec(content)) !== null) {
      const currentMatchIndex = match.index;
      if (currentMatchIndex > lastIndex) {
        const previousContent = content.substring(lastIndex, currentMatchIndex);
        if (chapters.length > 0) {
          const lastChapter = chapters[chapters.length - 1];
          lastChapter.content = previousContent.trim();
          lastChapter.endPosition = currentMatchIndex;
          lastChapter.wordCount = this.countWords(lastChapter.content);
          lastChapter.paragraphCount = this.countParagraphs(lastChapter.content);
          lastChapter.sentenceCount = this.countSentences(lastChapter.content);
        } else if (previousContent.trim()) {
          chapterIndex++;
          chapters.push({
            index: chapterIndex,
            title: "Prologue",
            content: previousContent.trim(),
            startPosition: lastIndex,
            endPosition: currentMatchIndex,
            wordCount: this.countWords(previousContent.trim()),
            paragraphCount: this.countParagraphs(previousContent.trim()),
            sentenceCount: this.countSentences(previousContent.trim())
          });
        }
      }
      chapterIndex++;
      chapters.push({
        index: chapterIndex,
        title: this.extractChapterTitle(match[0]),
        content: "",
        // Will be filled in next iteration or at the end
        startPosition: currentMatchIndex,
        endPosition: content.length,
        wordCount: 0,
        paragraphCount: 0,
        sentenceCount: 0
      });
      lastIndex = currentMatchIndex + match[0].length;
    }
    if (chapters.length > 0) {
      const lastChapter = chapters[chapters.length - 1];
      const finalContent = content.substring(lastIndex);
      lastChapter.content = finalContent.trim();
      lastChapter.endPosition = content.length;
      lastChapter.wordCount = this.countWords(lastChapter.content);
      lastChapter.paragraphCount = this.countParagraphs(lastChapter.content);
      lastChapter.sentenceCount = this.countSentences(lastChapter.content);
    }
    if (chapters.length === 0) {
      chapters.push({
        index: 1,
        title: "Content",
        content: content.trim(),
        startPosition: 0,
        endPosition: content.length,
        wordCount: this.countWords(content),
        paragraphCount: this.countParagraphs(content),
        sentenceCount: this.countSentences(content)
      });
    }
    return chapters;
  }
  isChapterHeading(line) {
    for (const pattern of _ManuscriptParser.CHAPTER_PATTERNS) {
      if (pattern.test(line.trim())) {
        return true;
      }
    }
    return false;
  }
  extractChapterTitle(line) {
    let title = line.replace(/^#+\s*/, "").trim();
    title = title.replace(/^(?:Capítulo|Chapter|Cap\.?)\s*\d+\s*[-–—:.]?\s*/i, "").trim();
    return title || `Chapter`;
  }
  extractTitle(frontMatter, fileName) {
    if (frontMatter.title && typeof frontMatter.title === "string") {
      return frontMatter.title;
    }
    return fileName.replace(/\.md$/i, "");
  }
  detectTableOfContents(content) {
    const tocPatterns = [
      /sumário/i,
      /table of contents/i,
      /índice/i,
      /contents/i
    ];
    const first2000Chars = content.substring(0, 2e3);
    return tocPatterns.some((pattern) => pattern.test(first2000Chars));
  }
  countWords(text) {
    if (!text)
      return 0;
    const matches = text.match(/\S+/g);
    return matches ? matches.length : 0;
  }
  countSentences(text) {
    if (!text)
      return 0;
    const matches = text.match(/[.!?…]+[\s\n]+/g);
    return (matches ? matches.length : 0) + 1;
  }
  countParagraphs(text) {
    if (!text)
      return 0;
    const matches = text.match(/\n\s*\n/g);
    return (matches ? matches.length : 0) + 1;
  }
  // Extract sentences for analysis
  extractSentences(text) {
    return text.split(_ManuscriptParser.SENTENCE_END).map((s) => s.trim()).filter((s) => s.length > 0);
  }
  // Extract paragraphs for analysis
  extractParagraphs(text) {
    return text.split(_ManuscriptParser.PARAGRAPH_SPLIT).map((p) => p.trim()).filter((p) => p.length > 0);
  }
  // Get text samples for AI detection
  getSamples(content, sampleSize = 500, sampleCount = 10) {
    const words = content.split(/\s+/);
    const totalWords = words.length;
    if (totalWords <= sampleSize * sampleCount) {
      return this.splitIntoChunks(content, Math.ceil(totalWords / sampleCount)).map((chunk) => chunk.slice(0, sampleSize));
    }
    const samples = [];
    const interval = Math.floor(totalWords / (sampleCount + 1));
    for (let i = 1; i <= sampleCount; i++) {
      const startIndex = interval * i;
      const sampleWords = words.slice(startIndex, startIndex + sampleSize);
      samples.push(sampleWords.join(" "));
    }
    return samples;
  }
  splitIntoChunks(content, wordsPerChunk) {
    const words = content.split(/\s+/);
    const chunks = [];
    for (let i = 0; i < words.length; i += wordsPerChunk) {
      chunks.push(words.slice(i, i + wordsPerChunk).join(" "));
    }
    return chunks;
  }
};
_ManuscriptParser.CHAPTER_PATTERNS = [
  /^#{1,2}\s+(?:Capítulo|Chapter|Cap\.?)\s*(\d+)/im,
  /^#{1,2}\s+(\d+)\s*[-–—:.]?\s*(.+)?$/im,
  /^(?:Capítulo|Chapter|Cap\.?)\s*(\d+)/im,
  /^#{1,2}\s+(.+)$/im
  // Generic heading
];
_ManuscriptParser.SENTENCE_END = /[.!?…]+[\s\n]+/g;
_ManuscriptParser.PARAGRAPH_SPLIT = /\n\s*\n/g;
var ManuscriptParser = _ManuscriptParser;

// src/core/chunk-manager.ts
var ChunkManager = class {
  constructor(settings) {
    this.settings = settings;
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  /**
   * Chunks a manuscript into processable segments.
   * Attempts to respect chapter boundaries when possible.
   */
  chunkManuscript(content, chapters) {
    const chunkSize = this.settings.chunkSize;
    const chunks = [];
    const chapterBoundaries = [];
    if (this.canUseChapterBoundaries(chapters, chunkSize)) {
      return this.chunkByChapters(chapters, chunkSize);
    }
    return this.chunkBySize(content, chunkSize);
  }
  canUseChapterBoundaries(chapters, chunkSize) {
    const avgChapterSize = chapters.reduce((sum, c) => sum + c.wordCount, 0) / chapters.length;
    return avgChapterSize <= chunkSize * 0.8;
  }
  chunkByChapters(chapters, maxChunkSize) {
    const chunks = [];
    const chapterBoundaries = [];
    let totalWords = 0;
    let currentChunk = {
      content: [],
      chapters: [],
      wordCount: 0
    };
    let position = 0;
    for (const chapter of chapters) {
      if (currentChunk.wordCount + chapter.wordCount > maxChunkSize && currentChunk.content.length > 0) {
        chunks.push({
          index: chunks.length,
          content: currentChunk.content.join("\n\n"),
          startPosition: position - currentChunk.content.join("\n\n").length,
          endPosition: position,
          wordCount: currentChunk.wordCount,
          chapterIndices: currentChunk.chapters
        });
        chapterBoundaries.push(chunks.length - 1);
        currentChunk = { content: [], chapters: [], wordCount: 0 };
      }
      if (chapter.wordCount > maxChunkSize) {
        if (currentChunk.content.length > 0) {
          chunks.push({
            index: chunks.length,
            content: currentChunk.content.join("\n\n"),
            startPosition: position - currentChunk.content.join("\n\n").length,
            endPosition: position,
            wordCount: currentChunk.wordCount,
            chapterIndices: currentChunk.chapters
          });
          currentChunk = { content: [], chapters: [], wordCount: 0 };
        }
        const subChunks = this.splitLargeChapter(chapter, maxChunkSize, chunks.length);
        chunks.push(...subChunks);
        position += chapter.content.length;
      } else {
        currentChunk.content.push(chapter.content);
        currentChunk.chapters.push(chapter.index);
        currentChunk.wordCount += chapter.wordCount;
        position += chapter.content.length + 2;
      }
      totalWords += chapter.wordCount;
    }
    if (currentChunk.content.length > 0) {
      chunks.push({
        index: chunks.length,
        content: currentChunk.content.join("\n\n"),
        startPosition: position - currentChunk.content.join("\n\n").length,
        endPosition: position,
        wordCount: currentChunk.wordCount,
        chapterIndices: currentChunk.chapters
      });
    }
    return {
      chunks,
      totalChunks: chunks.length,
      totalWords,
      chapterBoundaries
    };
  }
  splitLargeChapter(chapter, maxChunkSize, startIndex) {
    const chunks = [];
    const paragraphs = chapter.content.split(/\n\s*\n/).filter((p) => p.trim());
    let currentContent = [];
    let currentWordCount = 0;
    let position = chapter.startPosition;
    for (const paragraph of paragraphs) {
      const paragraphWords = this.countWords(paragraph);
      if (currentWordCount + paragraphWords > maxChunkSize && currentContent.length > 0) {
        chunks.push({
          index: startIndex + chunks.length,
          content: currentContent.join("\n\n"),
          startPosition: position,
          endPosition: position + currentContent.join("\n\n").length,
          wordCount: currentWordCount,
          chapterIndices: [chapter.index]
        });
        position += currentContent.join("\n\n").length + 2;
        currentContent = [];
        currentWordCount = 0;
      }
      currentContent.push(paragraph);
      currentWordCount += paragraphWords;
    }
    if (currentContent.length > 0) {
      chunks.push({
        index: startIndex + chunks.length,
        content: currentContent.join("\n\n"),
        startPosition: position,
        endPosition: position + currentContent.join("\n\n").length,
        wordCount: currentWordCount,
        chapterIndices: [chapter.index]
      });
    }
    return chunks;
  }
  chunkBySize(content, maxChunkSize) {
    const chunks = [];
    const paragraphs = content.split(/\n\s*\n/).filter((p) => p.trim());
    let currentContent = [];
    let currentWordCount = 0;
    let position = 0;
    let totalWords = 0;
    for (const paragraph of paragraphs) {
      const paragraphWords = this.countWords(paragraph);
      if (currentWordCount + paragraphWords > maxChunkSize && currentContent.length > 0) {
        chunks.push({
          index: chunks.length,
          content: currentContent.join("\n\n"),
          startPosition: position - currentContent.join("\n\n").length,
          endPosition: position,
          wordCount: currentWordCount,
          chapterIndices: []
          // Unknown without chapter parsing
        });
        currentContent = [];
        currentWordCount = 0;
      }
      currentContent.push(paragraph);
      currentWordCount += paragraphWords;
      totalWords += paragraphWords;
      position += paragraph.length + 2;
    }
    if (currentContent.length > 0) {
      chunks.push({
        index: chunks.length,
        content: currentContent.join("\n\n"),
        startPosition: position - currentContent.join("\n\n").length,
        endPosition: position,
        wordCount: currentWordCount,
        chapterIndices: []
      });
    }
    return {
      chunks,
      totalChunks: chunks.length,
      totalWords,
      chapterBoundaries: []
    };
  }
  countWords(text) {
    return text.split(/\s+/).filter((w) => w.length > 0).length;
  }
  /**
   * Estimates token count for a chunk.
   * Rough approximation: ~1.3 tokens per word for English,
   * ~1.5 for Portuguese due to longer words.
   */
  estimateTokens(wordCount, language = "pt-BR") {
    const multiplier = language.startsWith("pt") ? 1.5 : 1.3;
    return Math.ceil(wordCount * multiplier);
  }
  /**
   * Creates a summary context from multiple chunks for global analysis.
   * Useful for maintaining coherence across chunk boundaries.
   */
  createSummaryContext(chunks, summaryWordLimit = 500) {
    const summaries = [];
    const wordsPerChunk = Math.floor(summaryWordLimit / chunks.length);
    for (const chunk of chunks) {
      const words = chunk.content.split(/\s+/);
      const summary = words.slice(0, Math.min(wordsPerChunk, words.length)).join(" ");
      summaries.push(`[Chunk ${chunk.index + 1}]: ${summary}...`);
    }
    return summaries.join("\n\n");
  }
  /**
   * Merges chunk analysis results into a coherent whole.
   */
  mergeAnalysisResults(results, merger) {
    return merger(results);
  }
};

// src/analyzers/readability.ts
var _ReadabilityAnalyzer = class _ReadabilityAnalyzer {
  constructor(language = "pt-BR") {
    this.language = language;
  }
  analyze(text) {
    const sentences = this.extractSentences(text);
    const words = this.extractWords(text);
    const paragraphs = this.extractParagraphs(text);
    const totalSentences = sentences.length;
    const totalWords = words.length;
    const totalSyllables = this.countTotalSyllables(words);
    const complexWords = this.countComplexWords(words);
    const avgSentenceLength = totalWords / Math.max(totalSentences, 1);
    const avgSyllablesPerWord = totalSyllables / Math.max(totalWords, 1);
    const avgParagraphLength = totalWords / Math.max(paragraphs.length, 1);
    const avgWordLength = words.reduce((sum, w) => sum + w.length, 0) / Math.max(totalWords, 1);
    return {
      fleschKincaid: this.calculateFleschKincaid(avgSentenceLength, avgSyllablesPerWord),
      smog: this.calculateSMOG(complexWords, totalSentences),
      gunningFog: this.calculateGunningFog(avgSentenceLength, complexWords, totalWords),
      ari: this.calculateARI(totalWords, totalSentences, text.length),
      avgSentenceLength,
      avgParagraphLength,
      avgWordLength,
      complexWordRatio: complexWords / Math.max(totalWords, 1)
    };
  }
  /**
   * Flesch-Kincaid Grade Level
   * Higher = more difficult to read
   */
  calculateFleschKincaid(avgSentenceLength, avgSyllablesPerWord) {
    const factor = this.language.startsWith("pt") ? 1.05 : 1;
    return Math.max(0, 0.39 * avgSentenceLength + 11.8 * avgSyllablesPerWord * factor - 15.59);
  }
  /**
   * SMOG Index (Simple Measure of Gobbledygook)
   * Estimates years of education needed
   */
  calculateSMOG(complexWords, totalSentences) {
    if (totalSentences < 30) {
      const adjustedComplex = complexWords * (30 / Math.max(totalSentences, 1));
      return 1.043 * Math.sqrt(adjustedComplex) + 3.1291;
    }
    return 1.043 * Math.sqrt(complexWords * (30 / totalSentences)) + 3.1291;
  }
  /**
   * Gunning Fog Index
   * Estimates years of formal education needed
   */
  calculateGunningFog(avgSentenceLength, complexWords, totalWords) {
    const complexRatio = complexWords / Math.max(totalWords, 1);
    return 0.4 * (avgSentenceLength + 100 * complexRatio);
  }
  /**
   * Automated Readability Index
   * Based on characters per word and words per sentence
   */
  calculateARI(totalWords, totalSentences, totalChars) {
    const charsPerWord = totalChars / Math.max(totalWords, 1);
    const wordsPerSentence = totalWords / Math.max(totalSentences, 1);
    return 4.71 * charsPerWord + 0.5 * wordsPerSentence - 21.43;
  }
  extractSentences(text) {
    return text.split(/[.!?…]+/).map((s) => s.trim()).filter((s) => s.length > 0);
  }
  extractWords(text) {
    return text.replace(/[^\w\sáàâãéêíóôõúç]/gi, " ").split(/\s+/).filter((w) => w.length > 0);
  }
  extractParagraphs(text) {
    return text.split(/\n\s*\n/).map((p) => p.trim()).filter((p) => p.length > 0);
  }
  countTotalSyllables(words) {
    return words.reduce((total, word) => total + this.countSyllables(word), 0);
  }
  countSyllables(word) {
    word = word.toLowerCase();
    if (word.length <= 2)
      return 1;
    if (this.language.startsWith("pt")) {
      return this.countSyllablesPortuguese(word);
    }
    return this.countSyllablesEnglish(word);
  }
  countSyllablesPortuguese(word) {
    const vowelMatches = word.match(_ReadabilityAnalyzer.PT_VOWELS) || [];
    const diphthongMatches = word.match(_ReadabilityAnalyzer.PT_DIPHTHONGS) || [];
    let count = vowelMatches.length - diphthongMatches.length;
    const hiatusPatterns = /[aeo][aeo]/gi;
    const hiatusMatches = word.match(hiatusPatterns) || [];
    count += hiatusMatches.length;
    return Math.max(1, count);
  }
  countSyllablesEnglish(word) {
    word = word.replace(/e$/, "");
    const matches = word.match(_ReadabilityAnalyzer.EN_VOWELS) || [];
    let count = matches.length;
    if (word.endsWith("le") && word.length > 2)
      count++;
    if (word.endsWith("es") || word.endsWith("ed"))
      count--;
    return Math.max(1, count);
  }
  /**
   * Complex words = words with 3+ syllables
   * Excluding common suffixes and compound words
   */
  countComplexWords(words) {
    return words.filter((word) => {
      if (word.length < 6)
        return false;
      const syllables = this.countSyllables(word);
      if (syllables < 3)
        return false;
      const commonSuffixes = this.language.startsWith("pt") ? ["mente", "\xE7\xE3o", "\xE7\xF5es", "dade", "mento", "ando", "endo", "indo"] : ["ing", "ed", "es", "ly", "tion", "ness"];
      for (const suffix of commonSuffixes) {
        if (word.endsWith(suffix)) {
          const base = word.slice(0, -suffix.length);
          if (this.countSyllables(base) >= 2)
            return false;
        }
      }
      return true;
    }).length;
  }
  /**
   * Get readability interpretation
   */
  interpret(metrics) {
    const fk = metrics.fleschKincaid;
    if (fk <= 6) {
      return {
        level: "Muito F\xE1cil",
        audience: "Ensino Fundamental I",
        suggestion: "Apropriado para leitores jovens ou textos introdut\xF3rios"
      };
    } else if (fk <= 8) {
      return {
        level: "F\xE1cil",
        audience: "Ensino Fundamental II",
        suggestion: "Bom para p\xFAblico geral e fic\xE7\xE3o comercial"
      };
    } else if (fk <= 10) {
      return {
        level: "Moderado",
        audience: "Ensino M\xE9dio",
        suggestion: "Ideal para fic\xE7\xE3o adulta e n\xE3o-fic\xE7\xE3o acess\xEDvel"
      };
    } else if (fk <= 12) {
      return {
        level: "Moderadamente Dif\xEDcil",
        audience: "Ensino M\xE9dio Superior",
        suggestion: "Apropriado para fic\xE7\xE3o liter\xE1ria e n\xE3o-fic\xE7\xE3o especializada"
      };
    } else if (fk <= 14) {
      return {
        level: "Dif\xEDcil",
        audience: "Universit\xE1rio",
        suggestion: "Considere simplificar para p\xFAblicos mais amplos"
      };
    } else {
      return {
        level: "Muito Dif\xEDcil",
        audience: "P\xF3s-gradua\xE7\xE3o / Acad\xEAmico",
        suggestion: "Texto muito complexo; simplifica\xE7\xE3o recomendada"
      };
    }
  }
};
// Syllable patterns for Portuguese
_ReadabilityAnalyzer.PT_VOWELS = /[aáàâãeéêiíoóôõuú]/gi;
_ReadabilityAnalyzer.PT_DIPHTHONGS = /[aeiou][iuo]/gi;
// Syllable patterns for English
_ReadabilityAnalyzer.EN_VOWELS = /[aeiouy]+/gi;
var ReadabilityAnalyzer = _ReadabilityAnalyzer;

// src/analyzers/cadence.ts
var CadenceAnalyzer = class {
  /**
   * Analyzes the cadence and rhythm of the text.
   */
  analyze(content, chapters) {
    const sentences = this.extractSentences(content);
    const sentenceLengths = sentences.map((s) => this.countWords(s));
    const paragraphs = this.extractParagraphs(content);
    const paragraphLengths = paragraphs.map((p) => this.countWords(p));
    const burstiness = this.calculateBurstiness(sentenceLengths);
    const sentenceLengthVariance = this.calculateVariance(sentenceLengths);
    const paragraphLengthVariance = this.calculateVariance(paragraphLengths);
    const rhythmPattern = this.classifyRhythm(burstiness, sentenceLengthVariance);
    const pacingByChapter = chapters.map((chapter) => this.analyzeChapterPacing(chapter));
    return {
      burstiness,
      sentenceLengthVariance,
      paragraphLengthVariance,
      rhythmPattern,
      pacingByChapter
    };
  }
  /**
   * Burstiness measures the variation in consecutive sentence lengths.
   * Higher burstiness = more natural, varied prose.
   * AI-generated text often has lower burstiness (more uniform).
   * 
   * Formula: (σ - μ) / (σ + μ) where σ = std dev, μ = mean
   * Range: -1 to 1 (higher is more "bursty")
   */
  calculateBurstiness(lengths) {
    if (lengths.length < 2)
      return 0;
    const mean = lengths.reduce((a, b) => a + b, 0) / lengths.length;
    const variance = lengths.reduce((sum, l) => sum + Math.pow(l - mean, 2), 0) / lengths.length;
    const stdDev = Math.sqrt(variance);
    if (mean + stdDev === 0)
      return 0;
    return (stdDev - mean) / (stdDev + mean);
  }
  /**
   * Calculates statistical variance.
   */
  calculateVariance(values) {
    if (values.length === 0)
      return 0;
    const mean = values.reduce((a, b) => a + b, 0) / values.length;
    return values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length;
  }
  /**
   * Classifies the overall rhythm pattern.
   */
  classifyRhythm(burstiness, sentenceVariance) {
    const normalizedVariance = Math.sqrt(sentenceVariance);
    if (burstiness < -0.2 && normalizedVariance < 5) {
      return "uniform";
    } else if (burstiness > 0.3 || normalizedVariance > 15) {
      return "chaotic";
    } else {
      return "varied";
    }
  }
  /**
   * Analyzes pacing for a single chapter.
   */
  analyzeChapterPacing(chapter) {
    const sentences = this.extractSentences(chapter.content);
    const sentenceLengths = sentences.map((s) => this.countWords(s));
    const avgSentenceLength = sentenceLengths.length > 0 ? sentenceLengths.reduce((a, b) => a + b, 0) / sentenceLengths.length : 0;
    const burstiness = this.calculateBurstiness(sentenceLengths);
    let paceCategory;
    if (avgSentenceLength < 12) {
      paceCategory = "fast";
    } else if (avgSentenceLength > 20) {
      paceCategory = "slow";
    } else {
      paceCategory = "moderate";
    }
    return {
      chapter: chapter.index,
      avgSentenceLength,
      burstiness,
      paceCategory
    };
  }
  /**
   * Analyzes rhythm patterns within a passage.
   * Returns sequence of short (S), medium (M), long (L) sentences.
   */
  analyzeRhythmSequence(text) {
    const sentences = this.extractSentences(text);
    const lengths = sentences.map((s) => this.countWords(s));
    return lengths.map((len) => {
      if (len <= 8)
        return "S";
      if (len <= 20)
        return "M";
      return "L";
    }).join("");
  }
  /**
   * Detects rhythm repetition patterns.
   * Returns patterns that repeat more than expected.
   */
  detectRepetitivePatterns(text, patternLength = 3) {
    const sequence = this.analyzeRhythmSequence(text);
    const patterns = /* @__PURE__ */ new Map();
    for (let i = 0; i <= sequence.length - patternLength; i++) {
      const pattern = sequence.substring(i, i + patternLength);
      patterns.set(pattern, (patterns.get(pattern) || 0) + 1);
    }
    const threshold = Math.max(3, sequence.length / (Math.pow(3, patternLength) * 2));
    const repetitive = /* @__PURE__ */ new Map();
    for (const [pattern, count] of patterns) {
      if (count >= threshold) {
        repetitive.set(pattern, count);
      }
    }
    return repetitive;
  }
  /**
   * Calculates the "momentum" of a passage.
   * Momentum increases with shorter sentences and decreases with longer ones.
   */
  calculateMomentum(text) {
    const sentences = this.extractSentences(text);
    const momentum = [];
    let currentMomentum = 50;
    for (const sentence of sentences) {
      const words = this.countWords(sentence);
      if (words <= 8) {
        currentMomentum = Math.min(100, currentMomentum + 10);
      } else if (words <= 15) {
        currentMomentum = Math.min(100, currentMomentum + 3);
      } else if (words <= 25) {
        currentMomentum = Math.max(0, currentMomentum - 3);
      } else {
        currentMomentum = Math.max(0, currentMomentum - 10);
      }
      momentum.push(currentMomentum);
    }
    return momentum;
  }
  /**
   * Identifies "white space" usage (short paragraphs, dialogue breaks).
   */
  analyzeWhiteSpace(text) {
    const paragraphs = this.extractParagraphs(text);
    const shortParagraphs = paragraphs.filter((p) => this.countWords(p) <= 30);
    const dialogueParagraphs = paragraphs.filter(
      (p) => p.trim().startsWith("\u2014") || p.trim().startsWith('"') || p.trim().startsWith("\u2013") || p.trim().startsWith("-")
    );
    return {
      shortParagraphRatio: shortParagraphs.length / Math.max(paragraphs.length, 1),
      dialogueRatio: dialogueParagraphs.length / Math.max(paragraphs.length, 1),
      avgParagraphGap: paragraphs.length > 0 ? text.length / paragraphs.length : 0
    };
  }
  extractSentences(text) {
    return text.split(/[.!?…]+/).map((s) => s.trim()).filter((s) => s.length > 0);
  }
  extractParagraphs(text) {
    return text.split(/\n\s*\n/).map((p) => p.trim()).filter((p) => p.length > 0);
  }
  countWords(text) {
    return text.split(/\s+/).filter((w) => w.length > 0).length;
  }
  /**
   * Generates a cadence interpretation report.
   */
  interpret(metrics) {
    const strengths = [];
    const suggestions = [];
    if (metrics.burstiness >= 0.2) {
      strengths.push("Boa varia\xE7\xE3o no ritmo das frases, prosa natural");
    } else if (metrics.burstiness <= -0.1) {
      suggestions.push("Considere variar mais o comprimento das frases para melhor ritmo");
    }
    if (metrics.rhythmPattern === "varied") {
      strengths.push("Padr\xE3o r\xEDtmico equilibrado");
    } else if (metrics.rhythmPattern === "uniform") {
      suggestions.push("Ritmo muito uniforme; adicione mais varia\xE7\xE3o para engajamento");
    } else if (metrics.rhythmPattern === "chaotic") {
      suggestions.push("Ritmo irregular demais; considere suavizar transi\xE7\xF5es");
    }
    const fastChapters = metrics.pacingByChapter.filter((c) => c.paceCategory === "fast");
    const slowChapters = metrics.pacingByChapter.filter((c) => c.paceCategory === "slow");
    if (fastChapters.length > 0 && slowChapters.length > 0) {
      strengths.push("Boa varia\xE7\xE3o de ritmo entre cap\xEDtulos");
    }
    let summary = `Ritmo ${metrics.rhythmPattern === "varied" ? "balanceado" : metrics.rhythmPattern === "uniform" ? "uniforme" : "variado"} `;
    summary += `com burstiness de ${(metrics.burstiness * 100).toFixed(0)}%.`;
    return { summary, strengths, suggestions };
  }
};

// src/analyzers/ai-detection.ts
var ARTIFACT_MARKERS = {
  // Category A: Lexical Patterns
  A1: { name: "Sin\xF4nimos excessivos", weight: "high", category: "A" },
  A2: { name: "Vocabul\xE1rio elevado uniforme", weight: "medium", category: "A" },
  A3: { name: "Frases de \xEAnfase padronizadas", weight: "high", category: "A" },
  A4: { name: "Adv\xE9rbios de intensifica\xE7\xE3o", weight: "medium", category: "A" },
  A5: { name: "Conectivos formais", weight: "medium", category: "A" },
  A6: { name: "Hedging excessivo", weight: "medium", category: "A" },
  // Category B: Structural Patterns
  B1: { name: "Uniformidade frasal", weight: "high", category: "B" },
  B2: { name: "Par\xE1grafos sim\xE9tricos", weight: "medium", category: "B" },
  B3: { name: "Transi\xE7\xF5es mec\xE2nicas", weight: "medium", category: "B" },
  B4: { name: "Listas impl\xEDcitas", weight: "high", category: "B" },
  B5: { name: "Aus\xEAncia de fragmentos", weight: "medium", category: "B" },
  B6: { name: "Abertura-corpo-conclus\xE3o r\xEDgida", weight: "high", category: "B" },
  // Category C: Narrative Patterns (Fiction)
  C1: { name: "Di\xE1logos equilibrados", weight: "high", category: "C" },
  C2: { name: "Tags de di\xE1logo repetitivas", weight: "medium", category: "C" },
  C3: { name: "Descri\xE7\xF5es sensoriais gen\xE9ricas", weight: "high", category: "C" },
  C4: { name: "Emo\xE7\xF5es nomeadas (telling)", weight: "medium", category: "C" },
  C5: { name: "Backstory expositivo", weight: "medium", category: "C" },
  C6: { name: "Aus\xEAncia de coloquialismos", weight: "high", category: "C" },
  C7: { name: "Met\xE1foras convencionais", weight: "medium", category: "C" },
  C8: { name: "Vozes indistintas", weight: "high", category: "C" },
  // Category D: Statistical Patterns
  D1: { name: "Perplexidade baixa", weight: "high", category: "D" },
  D2: { name: "Burstiness baixa", weight: "high", category: "D" },
  D3: { name: "TTR anormal", weight: "medium", category: "D" },
  D4: { name: "Desvio da Lei de Zipf", weight: "high", category: "D" },
  D5: { name: "N-gramas repetitivos", weight: "high", category: "D" },
  D6: { name: "Entropia uniforme", weight: "medium", category: "D" },
  // Category E: Cultural/Temporal Patterns
  E1: { name: "Americanismos em contexto n\xE3o-americano", weight: "medium", category: "E" },
  E2: { name: "Anacronismos lexicais", weight: "high", category: "E" },
  E3: { name: "Neutralidade cultural excessiva", weight: "medium", category: "E" },
  E4: { name: "Formalidade consistente", weight: "high", category: "E" },
  E5: { name: "Conhecimento enciclop\xE9dico", weight: "medium", category: "E" }
};
var AI_PHRASES_PT = [
  "vale ressaltar",
  "\xE9 importante destacar",
  "nesse sentido",
  "diante disso",
  "tendo em vista",
  "por conseguinte",
  "em suma",
  "al\xE9m disso",
  "no entanto",
  "ademais",
  "outrossim",
  "destarte",
  "n\xE3o obstante",
  "indubitavelmente",
  "inegavelmente",
  "certamente",
  "evidentemente",
  "claramente"
];
var AI_PHRASES_EN = [
  "it's worth noting",
  "plays a vital role",
  "stands as a testament",
  "underscores the importance",
  "in conclusion",
  "furthermore",
  "moreover",
  "additionally",
  "consequently",
  "significantly",
  "remarkably",
  "profoundly",
  "undeniably",
  "incredibly",
  "it seems",
  "appears to",
  "might suggest"
];
var AIDetectionAnalyzer = class {
  constructor(llmService, settings) {
    this.llmService = llmService;
    this.settings = settings;
  }
  async analyze(content, chapters, onProgress) {
    const artifacts = [];
    const sampleAnalysis = [];
    onProgress == null ? void 0 : onProgress("Collecting samples...");
    const samples = this.collectSamples(content, chapters);
    onProgress == null ? void 0 : onProgress("Running statistical analysis...");
    const statisticalArtifacts = this.analyzeStatistical(content);
    artifacts.push(...statisticalArtifacts);
    onProgress == null ? void 0 : onProgress("Analyzing lexical patterns...");
    const lexicalArtifacts = this.analyzeLexicalPatterns(content);
    artifacts.push(...lexicalArtifacts);
    onProgress == null ? void 0 : onProgress("Analyzing structural patterns...");
    const structuralArtifacts = this.analyzeStructuralPatterns(content);
    artifacts.push(...structuralArtifacts);
    onProgress == null ? void 0 : onProgress("Running AI-assisted analysis on samples...");
    for (let i = 0; i < samples.length; i++) {
      onProgress == null ? void 0 : onProgress(`Analyzing sample ${i + 1}/${samples.length}...`);
      const sample = samples[i];
      const analysis = await this.analyzeSample(sample, i);
      sampleAnalysis.push(analysis);
    }
    const iul = this.calculateIUL(artifacts, sampleAnalysis);
    return {
      iul,
      classification: this.classifyIUL(iul),
      artifacts,
      sampleAnalysis
    };
  }
  collectSamples(content, chapters) {
    const targetSampleCount = 10;
    const targetSampleSize = 400;
    if (chapters.length <= targetSampleCount) {
      return chapters.map((ch) => {
        const words = ch.content.split(/\s+/);
        return words.slice(0, targetSampleSize).join(" ");
      });
    }
    const samples = [];
    const interval = Math.floor(chapters.length / targetSampleCount);
    for (let i = 0; i < targetSampleCount; i++) {
      const chapterIndex = Math.min(i * interval, chapters.length - 1);
      const chapter = chapters[chapterIndex];
      const words = chapter.content.split(/\s+/);
      samples.push(words.slice(0, targetSampleSize).join(" "));
    }
    return samples;
  }
  analyzeStatistical(content) {
    const artifacts = [];
    const sentences = content.split(/[.!?]+/).filter((s) => s.trim());
    const words = content.toLowerCase().split(/\s+/).filter((w) => w.length > 0);
    const sentenceLengths = sentences.map((s) => s.split(/\s+/).length);
    const burstiness = this.calculateBurstiness(sentenceLengths);
    if (burstiness < 0.1) {
      artifacts.push(this.createArtifact("D2", [{
        location: "Global",
        excerpt: `Burstiness: ${burstiness.toFixed(3)} (baixa varia\xE7\xE3o)`,
        chapterIndex: 0
      }]));
    }
    const uniqueWords = new Set(words);
    const ttr = uniqueWords.size / words.length;
    if (ttr < 0.12 || ttr > 0.35) {
      artifacts.push(this.createArtifact("D3", [{
        location: "Global",
        excerpt: `TTR: ${ttr.toFixed(3)} (${ttr < 0.12 ? "vocabul\xE1rio repetitivo" : "vocabul\xE1rio atipicamente diverso"})`,
        chapterIndex: 0
      }]));
    }
    const trigramRepetitions = this.findRepetitiveNgrams(words, 3);
    if (trigramRepetitions.length > 5) {
      artifacts.push(this.createArtifact("D5", trigramRepetitions.slice(0, 5).map((r) => ({
        location: "Multiple",
        excerpt: `"${r.ngram}" (${r.count}x)`,
        chapterIndex: 0
      }))));
    }
    return artifacts;
  }
  analyzeLexicalPatterns(content) {
    const artifacts = [];
    const phrases = this.settings.language.startsWith("pt") ? AI_PHRASES_PT : AI_PHRASES_EN;
    const contentLower = content.toLowerCase();
    const foundPhrases = [];
    for (const phrase of phrases) {
      const regex = new RegExp(phrase, "gi");
      const matches = contentLower.match(regex);
      if (matches && matches.length > 2) {
        foundPhrases.push({
          location: "Multiple",
          excerpt: `"${phrase}" (${matches.length}x)`,
          chapterIndex: 0
        });
      }
    }
    if (foundPhrases.length >= 3) {
      artifacts.push(this.createArtifact("A3", foundPhrases));
    }
    const intensifiers = this.settings.language.startsWith("pt") ? ["notavelmente", "significativamente", "profundamente", "inegavelmente", "incrivelmente", "realmente", "verdadeiramente"] : ["remarkably", "significantly", "profoundly", "undeniably", "incredibly", "truly", "really"];
    const intensifierCount = intensifiers.reduce((count, adv) => {
      var _a;
      const regex = new RegExp(`\\b${adv}\\b`, "gi");
      return count + (((_a = contentLower.match(regex)) == null ? void 0 : _a.length) || 0);
    }, 0);
    const wordCount = content.split(/\s+/).length;
    if (intensifierCount / wordCount > 5e-3) {
      artifacts.push(this.createArtifact("A4", [{
        location: "Global",
        excerpt: `${intensifierCount} intensificadores em ${wordCount} palavras (${(intensifierCount / wordCount * 100).toFixed(2)}%)`,
        chapterIndex: 0
      }]));
    }
    const connectives = this.settings.language.startsWith("pt") ? ["ademais", "outrossim", "destarte", "por conseguinte", "n\xE3o obstante", "porquanto"] : ["furthermore", "moreover", "additionally", "consequently", "henceforth", "whereby"];
    const connectiveInstances = [];
    for (const conn of connectives) {
      const regex = new RegExp(`\\b${conn}\\b`, "gi");
      const matches = contentLower.match(regex);
      if (matches && matches.length > 0) {
        connectiveInstances.push({
          location: "Multiple",
          excerpt: `"${conn}" (${matches.length}x)`,
          chapterIndex: 0
        });
      }
    }
    if (connectiveInstances.length >= 4) {
      artifacts.push(this.createArtifact("A5", connectiveInstances));
    }
    return artifacts;
  }
  analyzeStructuralPatterns(content) {
    const artifacts = [];
    const sentences = content.split(/[.!?]+/).filter((s) => s.trim());
    const paragraphs = content.split(/\n\s*\n/).filter((p) => p.trim());
    const sentenceLengths = sentences.map((s) => s.split(/\s+/).length);
    const variance = this.calculateVariance(sentenceLengths);
    const mean = sentenceLengths.reduce((a, b) => a + b, 0) / sentenceLengths.length;
    const coefficientOfVariation = Math.sqrt(variance) / mean;
    if (coefficientOfVariation < 0.3) {
      artifacts.push(this.createArtifact("B1", [{
        location: "Global",
        excerpt: `Coeficiente de varia\xE7\xE3o: ${coefficientOfVariation.toFixed(3)} (frases muito uniformes)`,
        chapterIndex: 0
      }]));
    }
    const paragraphLengths = paragraphs.map((p) => p.split(/\s+/).length);
    const paragraphVariance = this.calculateVariance(paragraphLengths);
    const paragraphMean = paragraphLengths.reduce((a, b) => a + b, 0) / paragraphLengths.length;
    const paragraphCV = Math.sqrt(paragraphVariance) / paragraphMean;
    if (paragraphCV < 0.25 && paragraphs.length > 10) {
      artifacts.push(this.createArtifact("B2", [{
        location: "Global",
        excerpt: `CV par\xE1grafos: ${paragraphCV.toFixed(3)} (par\xE1grafos muito sim\xE9tricos)`,
        chapterIndex: 0
      }]));
    }
    const listPatterns = this.settings.language.startsWith("pt") ? [/primeiro[,.]?\s+.*segundo[,.]?\s+.*terceiro/gi, /em primeiro lugar.*em segundo.*em terceiro/gi] : [/first[,.]?\s+.*second[,.]?\s+.*third/gi, /firstly.*secondly.*thirdly/gi];
    for (const pattern of listPatterns) {
      if (pattern.test(content)) {
        artifacts.push(this.createArtifact("B4", [{
          location: "Multiple",
          excerpt: "Estrutura de lista impl\xEDcita detectada",
          chapterIndex: 0
        }]));
        break;
      }
    }
    return artifacts;
  }
  async analyzeSample(sample, index) {
    const prompt = this.buildAnalysisPrompt(sample);
    try {
      const response = await this.llmService.complete({
        prompt,
        systemPrompt: this.getDetectionSystemPrompt(),
        maxTokens: 500,
        temperature: 0.3
      });
      const artifactsFound = this.parseArtifactsFromResponse(response.content);
      const localIul = this.estimateLocalIUL(artifactsFound);
      return {
        sampleIndex: index,
        location: `Sample ${index + 1}`,
        wordCount: sample.split(/\s+/).length,
        artifactsFound,
        localIul
      };
    } catch (error) {
      console.error("Sample analysis failed:", error);
      return {
        sampleIndex: index,
        location: `Sample ${index + 1}`,
        wordCount: sample.split(/\s+/).length,
        artifactsFound: [],
        localIul: 0
      };
    }
  }
  buildAnalysisPrompt(sample) {
    return `Analise o seguinte trecho de texto e identifique artefatos que sugerem gera\xE7\xE3o por IA.

Procure por:
- Frases padronizadas ou clich\xEAs de LLM
- Uniformidade excessiva no comprimento das frases
- Vocabul\xE1rio artificialmente elevado
- Aus\xEAncia de coloquialismos ou marcas pessoais
- Descri\xE7\xF5es gen\xE9ricas sem detalhes idiossincr\xE1ticos
- Transi\xE7\xF5es mec\xE2nicas entre ideias

TEXTO:
"""
${sample}
"""

Responda APENAS com uma lista de c\xF3digos de artefatos encontrados (A1, B2, C3, etc.) e uma breve justificativa para cada. Se nenhum artefato for encontrado, responda "NENHUM".`;
  }
  getDetectionSystemPrompt() {
    return `Voc\xEA \xE9 um especialista em an\xE1lise forense de textos, treinado para identificar padr\xF5es de gera\xE7\xE3o por modelos de linguagem (LLMs).

Seu trabalho \xE9 identificar artefatos textuais que indicam uso de IA, usando os seguintes c\xF3digos:

CATEGORIA A - Padr\xF5es Lexicais:
A1: Sin\xF4nimos excessivos
A2: Vocabul\xE1rio elevado uniforme
A3: Frases de \xEAnfase padronizadas
A4: Adv\xE9rbios de intensifica\xE7\xE3o em excesso
A5: Conectivos formais excessivos
A6: Hedging excessivo

CATEGORIA B - Padr\xF5es Estruturais:
B1: Uniformidade frasal
B2: Par\xE1grafos sim\xE9tricos
B3: Transi\xE7\xF5es mec\xE2nicas
B4: Listas impl\xEDcitas
B5: Aus\xEAncia de fragmentos
B6: Estrutura abertura-corpo-conclus\xE3o r\xEDgida

CATEGORIA C - Padr\xF5es Narrativos:
C1: Di\xE1logos equilibrados demais
C2: Tags de di\xE1logo repetitivas
C3: Descri\xE7\xF5es sensoriais gen\xE9ricas
C4: Emo\xE7\xF5es nomeadas (telling)
C5: Backstory expositivo
C6: Aus\xEAncia de coloquialismos
C7: Met\xE1foras convencionais
C8: Vozes de personagens indistintas

Seja objetivo e espec\xEDfico. N\xE3o fa\xE7a julgamentos morais.`;
  }
  parseArtifactsFromResponse(response) {
    const artifactCodes = Object.keys(ARTIFACT_MARKERS);
    const found = [];
    for (const code of artifactCodes) {
      if (response.includes(code)) {
        found.push(code);
      }
    }
    return found;
  }
  estimateLocalIUL(artifactCodes) {
    if (artifactCodes.length === 0)
      return 0;
    let totalWeight = 0;
    for (const code of artifactCodes) {
      const marker = ARTIFACT_MARKERS[code];
      if (marker) {
        totalWeight += marker.weight === "high" ? 3 : marker.weight === "medium" ? 2 : 1;
      }
    }
    return Math.min(100, totalWeight / 15 * 100);
  }
  calculateIUL(artifacts, samples) {
    let artifactScore = 0;
    for (const artifact of artifacts) {
      const weight = artifact.weight === "high" ? 3 : artifact.weight === "medium" ? 2 : 1;
      artifactScore += weight * artifact.instances.length;
    }
    const avgSampleIUL = samples.length > 0 ? samples.reduce((sum, s) => sum + s.localIul, 0) / samples.length : 0;
    const combinedScore = avgSampleIUL * 0.6 + Math.min(100, artifactScore * 2) * 0.4;
    return Math.round(Math.min(100, combinedScore));
  }
  classifyIUL(iul) {
    if (iul <= 15)
      return "authentic";
    if (iul <= 35)
      return "assisted";
    if (iul <= 60)
      return "hybrid";
    if (iul <= 85)
      return "predominantly-ai";
    return "ai-generated";
  }
  createArtifact(code, instances) {
    const marker = ARTIFACT_MARKERS[code];
    return {
      code,
      category: marker.category,
      marker: marker.name,
      description: marker.name,
      weight: marker.weight,
      instances
    };
  }
  calculateBurstiness(lengths) {
    if (lengths.length < 2)
      return 0;
    const mean = lengths.reduce((a, b) => a + b, 0) / lengths.length;
    const variance = this.calculateVariance(lengths);
    const stdDev = Math.sqrt(variance);
    if (mean + stdDev === 0)
      return 0;
    return (stdDev - mean) / (stdDev + mean);
  }
  calculateVariance(values) {
    if (values.length === 0)
      return 0;
    const mean = values.reduce((a, b) => a + b, 0) / values.length;
    return values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length;
  }
  findRepetitiveNgrams(words, n) {
    const ngrams = /* @__PURE__ */ new Map();
    for (let i = 0; i <= words.length - n; i++) {
      const ngram = words.slice(i, i + n).join(" ");
      ngrams.set(ngram, (ngrams.get(ngram) || 0) + 1);
    }
    return Array.from(ngrams.entries()).filter(([_, count]) => count > 3).map(([ngram, count]) => ({ ngram, count })).sort((a, b) => b.count - a.count);
  }
};

// src/personas/helena-vasconcelos.ts
var HELENA_SYSTEM_PROMPT = `Voc\xEA \xE9 Helena Vasconcelos, Leitora Beta S\xEAnior e Analista de Manuscritos com 15 anos de experi\xEAncia editorial e especializa\xE7\xE3o em detec\xE7\xE3o de artefatos de IA.

FILOSOFIA DE TRABALHO:
"Diagn\xF3stico antes de prescri\xE7\xE3o. Um bom relat\xF3rio identifica o problema com precis\xE3o antes de sugerir solu\xE7\xF5es."

PRINC\xCDPIOS:
1. Especificidade \u2014 Apontar exemplos concretos, n\xE3o generaliza\xE7\xF5es
2. Equil\xEDbrio \u2014 Reconhecer pontos fortes antes de abordar fragilidades
3. Acionabilidade \u2014 Toda cr\xEDtica deve vir acompanhada de dire\xE7\xE3o para melhoria
4. Respeito \xE0 voz autoral \u2014 Preservar a identidade do autor enquanto aprimora a t\xE9cnica

TOM DE COMUNICA\xC7\xC3O:
- Direta sem ser rude
- Construtiva sem ser condescendente
- T\xE9cnica mas acess\xEDvel
- Honesta mesmo quando desconfort\xE1vel
- Encorajadora quando genu\xEDno

ESCALA DE AVALIA\xC7\xC3O (1-5):
5 = Excelente (Pronto para publica\xE7\xE3o)
4 = Bom (Requer polimento menor)
3 = Adequado (Espa\xE7o significativo para melhoria)
2 = Fraco (Requer retrabalho substancial)
1 = Cr\xEDtico (Problema fundamental que compromete a obra)

Voc\xEA N\xC3O:
- Faz copyediting ou revis\xE3o gramatical detalhada
- Escreve ou reescreve trechos no lugar do autor
- Avalia potencial comercial ou faz previs\xF5es de vendas
- Garante sucesso de publica\xE7\xE3o`;
var HelenaVasconcelosPersona = class {
  constructor(llmService, settings) {
    this.llmService = llmService;
    this.settings = settings;
  }
  /**
   * Analyzes overall literary quality across all dimensions.
   */
  async analyzeLiteraryQuality(content, structure, chunks, onProgress) {
    onProgress == null ? void 0 : onProgress("Analyzing narrative structure...");
    const structureScore = await this.scoreStructure(content, structure);
    onProgress == null ? void 0 : onProgress("Analyzing coherence...");
    const coherenceScore = await this.scoreCoherence(content, structure);
    onProgress == null ? void 0 : onProgress("Analyzing characters...");
    const charactersScore = await this.scoreCharacters(content, structure);
    onProgress == null ? void 0 : onProgress("Analyzing voice and style...");
    const voiceScore = await this.scoreVoice(content, structure);
    onProgress == null ? void 0 : onProgress("Analyzing pacing...");
    const pacingScore = await this.scorePacing(content, structure);
    onProgress == null ? void 0 : onProgress("Analyzing worldbuilding...");
    const worldbuildingScore = await this.scoreWorldbuilding(content, structure);
    onProgress == null ? void 0 : onProgress("Analyzing theme...");
    const themeScore = await this.scoreTheme(content, structure);
    onProgress == null ? void 0 : onProgress("Analyzing genre conformity...");
    const genreScore = await this.scoreGenreConformity(content, structure);
    onProgress == null ? void 0 : onProgress("Generating synopsis...");
    const synopsis = await this.generateSynopsis(content, structure);
    onProgress == null ? void 0 : onProgress("Identifying strengths and improvements...");
    const { strengths, improvements } = await this.identifyStrengthsAndImprovements(
      content,
      structure,
      {
        structureScore,
        coherenceScore,
        charactersScore,
        voiceScore,
        pacingScore,
        worldbuildingScore,
        themeScore,
        genreScore
      }
    );
    const overallScore = this.calculateOverallScore({
      structureScore,
      coherenceScore,
      charactersScore,
      voiceScore,
      pacingScore,
      worldbuildingScore,
      themeScore,
      genreScore
    });
    return {
      synopsis,
      structureScore,
      coherenceScore,
      charactersScore,
      voiceScore,
      pacingScore,
      worldbuildingScore,
      themeScore,
      genreConformityScore: genreScore,
      overallScore,
      strengths,
      improvements
    };
  }
  /**
   * Analyzes narrative structure using Save the Cat beats.
   */
  async analyzeStructure(content, structure, onProgress) {
    onProgress == null ? void 0 : onProgress("Identifying narrative beats...");
    const act1Content = this.getContentPortion(structure.chapters, 0, 0.25);
    const act2Content = this.getContentPortion(structure.chapters, 0.25, 0.75);
    const act3Content = this.getContentPortion(structure.chapters, 0.75, 1);
    const beats = await this.identifyBeats(content, structure);
    const turningPoints = await this.identifyTurningPoints(content, structure);
    const totalWords = structure.totalWords;
    const act1Words = this.countWordsInPortion(structure.chapters, 0, 0.25);
    const act2Words = this.countWordsInPortion(structure.chapters, 0.25, 0.75);
    const act3Words = totalWords - act1Words - act2Words;
    const acts = {
      act1Percentage: Math.round(act1Words / totalWords * 100),
      act2Percentage: Math.round(act2Words / totalWords * 100),
      act3Percentage: Math.round(act3Words / totalWords * 100),
      balanceScore: this.scoreActBalance(act1Words, act2Words, act3Words, totalWords)
    };
    const causalityScore = await this.analyzeCausality(content, structure);
    return {
      acts,
      beats,
      turningPoints,
      causalityScore
    };
  }
  /**
   * Analyzes coherence and consistency.
   */
  async analyzeCoherence(content, structure, onProgress) {
    onProgress == null ? void 0 : onProgress("Checking timeline consistency...");
    const prompt = `Analise a coer\xEAncia e consist\xEAncia do seguinte manuscrito.

T\xCDTULO: ${structure.title}
CAP\xCDTULOS: ${structure.chapters.length}
PALAVRAS: ${structure.totalWords}

PRIMEIROS CAP\xCDTULOS (contexto):
${this.getSampleContent(structure.chapters, 0, 3)}

CAP\xCDTULOS DO MEIO:
${this.getSampleContent(structure.chapters, Math.floor(structure.chapters.length / 2), 2)}

CAP\xCDTULOS FINAIS:
${this.getSampleContent(structure.chapters, structure.chapters.length - 2, 2)}

Identifique:
1. Inconsist\xEAncias na timeline/cronologia
2. Mudan\xE7as inexplicadas em caracter\xEDsticas de personagens
3. Plot holes (lacunas na trama)
4. Chekhov's guns n\xE3o resolvidos (elementos introduzidos sem payoff)
5. Inconsist\xEAncias no worldbuilding

Responda em JSON:
{
  "score": (1-5),
  "timelineIssues": ["..."],
  "characterInconsistencies": ["..."],
  "plotHoles": ["..."],
  "unresolvedElements": ["..."],
  "worldbuildingIssues": ["..."]
}`;
    try {
      const response = await this.llmService.complete({
        prompt,
        systemPrompt: HELENA_SYSTEM_PROMPT,
        maxTokens: 1500,
        temperature: 0.3
      });
      const result = this.parseJSON(response.content);
      const issues = [
        ...Array.isArray(result == null ? void 0 : result.timelineIssues) ? result.timelineIssues : [],
        ...Array.isArray(result == null ? void 0 : result.characterInconsistencies) ? result.characterInconsistencies : [],
        ...Array.isArray(result == null ? void 0 : result.plotHoles) ? result.plotHoles : [],
        ...Array.isArray(result == null ? void 0 : result.unresolvedElements) ? result.unresolvedElements : [],
        ...Array.isArray(result == null ? void 0 : result.worldbuildingIssues) ? result.worldbuildingIssues : []
      ];
      return {
        score: typeof (result == null ? void 0 : result.score) === "number" ? result.score : 3,
        issues
      };
    } catch (error) {
      console.error("Coherence analysis failed:", error);
      return { score: 3, issues: [] };
    }
  }
  async scoreStructure(content, structure) {
    const prompt = `Avalie a ESTRUTURA NARRATIVA deste manuscrito de 1 a 5.

Considere:
- Presen\xE7a e posicionamento dos beats narrativos (Save the Cat)
- Propor\xE7\xE3o dos atos (ideal: 25%-50%-25%)
- Timing dos turning points
- Causalidade (causa \u2192 efeito)

T\xCDTULO: ${structure.title}
CAP\xCDTULOS: ${structure.chapters.length}
PALAVRAS: ${structure.totalWords}

AMOSTRA DO IN\xCDCIO:
${this.getSampleContent(structure.chapters, 0, 2)}

AMOSTRA DO MEIO:
${this.getSampleContent(structure.chapters, Math.floor(structure.chapters.length / 2), 1)}

AMOSTRA DO FIM:
${this.getSampleContent(structure.chapters, structure.chapters.length - 1, 1)}

Responda APENAS com um n\xFAmero de 1 a 5.`;
    return this.getScoreFromLLM(prompt);
  }
  async scoreCoherence(content, structure) {
    const analysis = await this.analyzeCoherence(content, structure);
    return analysis.score;
  }
  async scoreCharacters(content, structure) {
    const prompt = `Avalie os PERSONAGENS deste manuscrito de 1 a 5.

Considere:
- Arco do protagonista (want/need/transformation)
- Profundidade do antagonista
- Distin\xE7\xE3o das vozes
- Caracteriza\xE7\xE3o (STEAL: Speech, Thoughts, Effects, Actions, Looks)

T\xCDTULO: ${structure.title}

AMOSTRA COM DI\xC1LOGOS:
${this.findDialogueSample(structure.chapters)}

Responda APENAS com um n\xFAmero de 1 a 5.`;
    return this.getScoreFromLLM(prompt);
  }
  async scoreVoice(content, structure) {
    const prompt = `Avalie a VOZ E ESTILO deste manuscrito de 1 a 5.

Considere:
- Consist\xEAncia do POV
- Tom e atmosfera
- Qualidade da prosa
- Show vs Tell
- Voz narrativa distintiva

AMOSTRA:
${this.getSampleContent(structure.chapters, 0, 2)}

Responda APENAS com um n\xFAmero de 1 a 5.`;
    return this.getScoreFromLLM(prompt);
  }
  async scorePacing(content, structure) {
    const prompt = `Avalie o RITMO E PACING deste manuscrito de 1 a 5.

Considere:
- Macro-pacing (distribui\xE7\xE3o de tens\xE3o nos atos)
- Micro-pacing (ritmo de cenas e par\xE1grafos)
- Equil\xEDbrio cena/sum\xE1rio
- Uso de cliffhangers

CAP\xCDTULOS: ${structure.chapters.length}
M\xC9DIA PALAVRAS/CAP\xCDTULO: ${Math.round(structure.totalWords / structure.chapters.length)}

AMOSTRA DE CENA DE A\xC7\xC3O (se dispon\xEDvel):
${this.findActionSample(structure.chapters)}

Responda APENAS com um n\xFAmero de 1 a 5.`;
    return this.getScoreFromLLM(prompt);
  }
  async scoreWorldbuilding(content, structure) {
    const prompt = `Avalie o WORLDBUILDING E CEN\xC1RIO deste manuscrito de 1 a 5.

Considere:
- Constru\xE7\xE3o de mundo consistente
- Sensorialidade (5 sentidos)
- Integra\xE7\xE3o org\xE2nica com a narrativa
- Detalhes espec\xEDficos vs gen\xE9ricos

AMOSTRA DESCRITIVA:
${this.findDescriptiveSample(structure.chapters)}

Responda APENAS com um n\xFAmero de 1 a 5.`;
    return this.getScoreFromLLM(prompt);
  }
  async scoreTheme(content, structure) {
    const prompt = `Avalie o TEMA E SUBTEXTO deste manuscrito de 1 a 5.

Considere:
- Clareza do tema central
- Theme stated (momento onde o tema \xE9 enunciado)
- Uso de s\xEDmbolos e motivos
- Resson\xE2ncia emocional

IN\xCDCIO (onde tema costuma ser apresentado):
${this.getSampleContent(structure.chapters, 0, 1)}

FIM (onde tema costuma ser refor\xE7ado):
${this.getSampleContent(structure.chapters, structure.chapters.length - 1, 1)}

Responda APENAS com um n\xFAmero de 1 a 5.`;
    return this.getScoreFromLLM(prompt);
  }
  async scoreGenreConformity(content, structure) {
    const prompt = `Avalie a CONFORMIDADE DE G\xCANERO deste manuscrito de 1 a 5.

Baseado no conte\xFAdo, identifique o g\xEAnero prov\xE1vel e avalie:
- Ader\xEAncia \xE0s conven\xE7\xF5es do g\xEAnero
- Atendimento \xE0s expectativas dos leitores
- Posicionamento de mercado

AMOSTRA:
${this.getSampleContent(structure.chapters, 0, 2)}

Responda APENAS com um n\xFAmero de 1 a 5.`;
    return this.getScoreFromLLM(prompt);
  }
  async generateSynopsis(content, structure) {
    const prompt = `Gere uma SINOPSE ESTRUTURAL do manuscrito em 3-4 par\xE1grafos.

Inclua:
1. Premissa central (2-3 frases)
2. Arco narrativo principal (in\xEDcio, desenvolvimento, fim)
3. Conflito motor (o que impulsiona a narrativa)

T\xCDTULO: ${structure.title}
CAP\xCDTULOS: ${structure.chapters.length}

IN\xCDCIO:
${this.getSampleContent(structure.chapters, 0, 2)}

MEIO:
${this.getSampleContent(structure.chapters, Math.floor(structure.chapters.length / 2), 1)}

FIM:
${this.getSampleContent(structure.chapters, structure.chapters.length - 1, 1)}`;
    try {
      const response = await this.llmService.complete({
        prompt,
        systemPrompt: HELENA_SYSTEM_PROMPT,
        maxTokens: 800,
        temperature: 0.5
      });
      return response.content;
    } catch (e) {
      return "Sinopse n\xE3o dispon\xEDvel.";
    }
  }
  async identifyStrengthsAndImprovements(content, structure, scores) {
    const prompt = `Baseado na an\xE1lise do manuscrito, identifique pontos fortes e \xE1reas de melhoria.

SCORES:
- Estrutura: ${scores.structureScore}/5
- Coer\xEAncia: ${scores.coherenceScore}/5
- Personagens: ${scores.charactersScore}/5
- Voz/Estilo: ${scores.voiceScore}/5
- Pacing: ${scores.pacingScore}/5
- Worldbuilding: ${scores.worldbuildingScore}/5
- Tema: ${scores.themeScore}/5
- G\xEAnero: ${scores.genreScore}/5

AMOSTRA DO MANUSCRITO:
${this.getSampleContent(structure.chapters, 0, 2)}

Responda em JSON:
{
  "strengths": ["ponto forte 1", "ponto forte 2", ...],
  "improvements": [
    {"priority": "high|medium|low", "area": "\xE1rea", "description": "problema", "suggestion": "sugest\xE3o"}
  ]
}`;
    try {
      const response = await this.llmService.complete({
        prompt,
        systemPrompt: HELENA_SYSTEM_PROMPT,
        maxTokens: 1e3,
        temperature: 0.4
      });
      const result = this.parseJSON(response.content);
      return {
        strengths: Array.isArray(result == null ? void 0 : result.strengths) ? result.strengths : [],
        improvements: Array.isArray(result == null ? void 0 : result.improvements) ? result.improvements : []
      };
    } catch (e) {
      return { strengths: [], improvements: [] };
    }
  }
  async identifyBeats(content, structure) {
    const beatNames = [
      "Opening Image / Setup",
      "Theme Stated",
      "Catalyst",
      "Debate",
      "Break Into Two",
      "B Story",
      "Fun & Games",
      "Midpoint",
      "Bad Guys Close In",
      "All Is Lost",
      "Dark Night of the Soul",
      "Break Into Three",
      "Finale",
      "Final Image"
    ];
    return beatNames.map((name, index) => ({
      name,
      present: true,
      // Placeholder
      position: Math.round(index / beatNames.length * 100),
      chapter: Math.max(1, Math.floor(index / beatNames.length * structure.chapters.length)),
      efficacy: 3
      // Placeholder
    }));
  }
  async identifyTurningPoints(content, structure) {
    return [
      { name: "Inciting Incident", chapter: 1, position: 10, strength: 3 },
      { name: "First Plot Point", chapter: Math.floor(structure.chapters.length * 0.25), position: 25, strength: 3 },
      { name: "Midpoint", chapter: Math.floor(structure.chapters.length * 0.5), position: 50, strength: 3 },
      { name: "Second Plot Point", chapter: Math.floor(structure.chapters.length * 0.75), position: 75, strength: 3 },
      { name: "Climax", chapter: structure.chapters.length - 1, position: 90, strength: 3 }
    ];
  }
  async analyzeCausality(content, structure) {
    return 3;
  }
  async getScoreFromLLM(prompt) {
    try {
      const response = await this.llmService.complete({
        prompt,
        systemPrompt: HELENA_SYSTEM_PROMPT,
        maxTokens: 50,
        temperature: 0.2
      });
      const score = parseInt(response.content.trim());
      if (score >= 1 && score <= 5)
        return score;
      return 3;
    } catch (e) {
      return 3;
    }
  }
  calculateOverallScore(scores) {
    const values = Object.values(scores);
    return Math.round(values.reduce((a, b) => a + b, 0) / values.length * 10) / 10;
  }
  scoreActBalance(act1, act2, act3, total) {
    const ideal = { act1: 0.25, act2: 0.5, act3: 0.25 };
    const actual = { act1: act1 / total, act2: act2 / total, act3: act3 / total };
    const deviation = Math.abs(ideal.act1 - actual.act1) + Math.abs(ideal.act2 - actual.act2) + Math.abs(ideal.act3 - actual.act3);
    if (deviation < 0.1)
      return 5;
    if (deviation < 0.2)
      return 4;
    if (deviation < 0.3)
      return 3;
    if (deviation < 0.4)
      return 2;
    return 1;
  }
  getSampleContent(chapters, startIndex, count) {
    const samples = chapters.slice(startIndex, startIndex + count).map((ch) => {
      const words = ch.content.split(/\s+/);
      return `## ${ch.title || `Cap\xEDtulo ${ch.index}`}
${words.slice(0, 300).join(" ")}...`;
    });
    return samples.join("\n\n");
  }
  getContentPortion(chapters, startRatio, endRatio) {
    const startIndex = Math.floor(chapters.length * startRatio);
    const endIndex = Math.floor(chapters.length * endRatio);
    return chapters.slice(startIndex, endIndex).map((ch) => ch.content).join("\n\n");
  }
  countWordsInPortion(chapters, startRatio, endRatio) {
    const startIndex = Math.floor(chapters.length * startRatio);
    const endIndex = Math.floor(chapters.length * endRatio);
    return chapters.slice(startIndex, endIndex).reduce((sum, ch) => sum + ch.wordCount, 0);
  }
  findDialogueSample(chapters) {
    for (const chapter of chapters) {
      if (chapter.content.includes("\u2014") || chapter.content.includes('"')) {
        const lines = chapter.content.split("\n");
        const dialogueStart = lines.findIndex((l) => l.includes("\u2014") || l.includes('"'));
        if (dialogueStart >= 0) {
          return lines.slice(dialogueStart, dialogueStart + 20).join("\n");
        }
      }
    }
    return this.getSampleContent(chapters, 0, 1);
  }
  findActionSample(chapters) {
    for (const chapter of chapters) {
      const paragraphs = chapter.content.split(/\n\s*\n/);
      const actionPara = paragraphs.find((p) => {
        const sentences = p.split(/[.!?]+/);
        const avgLength = sentences.reduce((s, sent) => s + sent.split(/\s+/).length, 0) / sentences.length;
        return avgLength < 10 && sentences.length > 3;
      });
      if (actionPara)
        return actionPara;
    }
    return this.getSampleContent(chapters, Math.floor(chapters.length * 0.7), 1);
  }
  findDescriptiveSample(chapters) {
    const sensoryWords = ["viu", "ouviu", "sentiu", "cheiro", "sabor", "tocou", "olhou", "escutou"];
    for (const chapter of chapters) {
      const paragraphs = chapter.content.split(/\n\s*\n/);
      const descriptive = paragraphs.find(
        (p) => p.split(/\s+/).length > 50 && sensoryWords.some((w) => p.toLowerCase().includes(w))
      );
      if (descriptive)
        return descriptive;
    }
    return this.getSampleContent(chapters, 0, 1);
  }
  parseJSON(text) {
    try {
      const jsonMatch = text.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        return JSON.parse(jsonMatch[0]);
      }
    } catch (e) {
      console.error("JSON parse error:", e);
    }
    return {};
  }
};

// src/core/analysis-orchestrator.ts
var AnalysisOrchestrator = class {
  constructor(settings, llmService, cacheManager) {
    this.settings = settings;
    this.llmService = llmService;
    this.cacheManager = cacheManager;
    this.parser = new ManuscriptParser();
    this.chunkManager = new ChunkManager(settings);
    this.readabilityAnalyzer = new ReadabilityAnalyzer(settings.language);
    this.cadenceAnalyzer = new CadenceAnalyzer();
    this.aiDetectionAnalyzer = new AIDetectionAnalyzer(llmService, settings);
    this.helenaPersona = new HelenaVasconcelosPersona(llmService, settings);
  }
  async analyze(request, onProgress) {
    const progress = this.createProgressTracker(onProgress);
    progress.update("parsing", 0, 5, "Parsing manuscript structure...");
    const structure = this.parser.parse(request.manuscriptContent, request.manuscriptPath);
    progress.update("parsing", 1, 5, "Structure parsed");
    progress.update("chunking", 2, 5, "Preparing analysis chunks...");
    const chunks = this.chunkManager.chunkManuscript(
      request.manuscriptContent,
      structure.chapters
    );
    progress.update("chunking", 2, 5, `Created ${chunks.totalChunks} analysis chunks`);
    const totalAnalyses = request.selectedReports.length;
    let completedAnalyses = 0;
    const report = {
      metadata: {
        manuscriptTitle: structure.title,
        manuscriptPath: request.manuscriptPath,
        wordCount: structure.totalWords,
        chapterCount: structure.chapters.length,
        analysisDate: (/* @__PURE__ */ new Date()).toISOString(),
        persona: request.persona || "none",
        version: "0.1.0"
      }
    };
    const contentHash = this.cacheManager.hashContent(request.manuscriptContent);
    for (const reportType of request.selectedReports) {
      try {
        progress.update(
          "analyzing",
          3,
          5,
          `Running ${reportType} analysis... (${completedAnalyses + 1}/${totalAnalyses})`
        );
        const cached = this.cacheManager.get(
          request.manuscriptPath,
          reportType,
          contentHash
        );
        if (cached) {
          this.assignAnalysisResult(report, reportType, cached);
          completedAnalyses++;
          continue;
        }
        const result = await this.runAnalysis(
          reportType,
          request.manuscriptContent,
          structure,
          chunks,
          (subProgress) => {
            progress.update(
              "analyzing",
              3,
              5,
              `${reportType}: ${subProgress}`
            );
          }
        );
        await this.cacheManager.set(
          request.manuscriptPath,
          reportType,
          contentHash,
          result,
          this.settings.cacheDurationDays
        );
        this.assignAnalysisResult(report, reportType, result);
      } catch (error) {
        console.error(`Analysis ${reportType} failed:`, error);
        this.handleAnalysisFailure(report, reportType, error);
      } finally {
        completedAnalyses++;
      }
    }
    progress.update("synthesizing", 4, 5, "Generating executive summary...");
    report.executiveSummary = await this.generateExecutiveSummary(report, structure);
    progress.update("generating", 5, 5, "Analysis complete");
    return report;
  }
  async runAnalysis(type, content, structure, chunks, onSubProgress) {
    switch (type) {
      case "readability":
        onSubProgress("Calculating readability metrics...");
        return this.readabilityAnalyzer.analyze(content);
      case "cadence":
        onSubProgress("Analyzing rhythm and cadence...");
        return this.cadenceAnalyzer.analyze(content, structure.chapters);
      case "ai-detection":
        onSubProgress("Running DETECT-AI protocol...");
        return this.aiDetectionAnalyzer.analyze(content, structure.chapters, onSubProgress);
      case "literary-quality":
        onSubProgress("Performing literary quality analysis...");
        return this.helenaPersona.analyzeLiteraryQuality(
          content,
          structure,
          chunks,
          onSubProgress
        );
      case "structure":
        onSubProgress("Analyzing narrative structure...");
        return this.helenaPersona.analyzeStructure(
          content,
          structure,
          onSubProgress
        );
      case "coherence":
        onSubProgress("Checking coherence and consistency...");
        return this.helenaPersona.analyzeCoherence(
          content,
          structure,
          onSubProgress
        );
      default:
        throw new Error(`Unknown analysis type: ${type}`);
    }
  }
  assignAnalysisResult(report, type, result) {
    switch (type) {
      case "readability":
        report.readability = result;
        break;
      case "cadence":
        report.cadence = result;
        break;
      case "ai-detection":
        report.aiDetection = result;
        break;
      case "literary-quality":
        report.literaryQuality = result;
        break;
      case "structure":
        report.structure = result;
        break;
    }
  }
  handleAnalysisFailure(report, type, error) {
    if (!report.metadata) {
      report.metadata = {
        manuscriptTitle: "Unknown",
        manuscriptPath: "",
        wordCount: 0,
        chapterCount: 0,
        analysisDate: (/* @__PURE__ */ new Date()).toISOString(),
        persona: "none",
        version: "0.1.0"
      };
    }
    if (!report.metadata.errors) {
      report.metadata.errors = [];
    }
    report.metadata.errors.push({
      type,
      message: error.message || String(error),
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  async generateExecutiveSummary(report, structure) {
    const strengths = [];
    const improvements = [];
    const scores = {};
    if (report.readability) {
      const fk = report.readability.fleschKincaid;
      if (fk >= 8 && fk <= 12) {
        strengths.push("Readability level appropriate for general audience");
      } else if (fk > 14) {
        improvements.push({
          priority: "medium",
          area: "Readability",
          description: "Text may be too complex for target audience",
          suggestion: "Consider simplifying sentence structures and vocabulary"
        });
      }
      scores["readability"] = this.readabilityToScore(fk);
    }
    if (report.cadence) {
      if (report.cadence.rhythmPattern === "varied") {
        strengths.push("Good sentence rhythm variation");
      } else if (report.cadence.rhythmPattern === "uniform") {
        improvements.push({
          priority: "low",
          area: "Cadence",
          description: "Sentence rhythm is monotonous",
          suggestion: "Vary sentence lengths for better flow"
        });
      }
      scores["cadence"] = report.cadence.burstiness >= 0.3 ? 4 : 3;
    }
    if (report.aiDetection) {
      const iul = report.aiDetection.iul;
      if (iul <= 15) {
        strengths.push("Text shows authentic human voice");
      } else if (iul > 35) {
        improvements.push({
          priority: "high",
          area: "Authenticity",
          description: `High AI artifact index (${iul}%)`,
          suggestion: "Review and humanize flagged sections"
        });
      }
      scores["authenticity"] = iul <= 15 ? 5 : iul <= 35 ? 4 : iul <= 60 ? 3 : 2;
    }
    if (report.literaryQuality) {
      scores["structure"] = report.literaryQuality.structureScore;
      scores["characters"] = report.literaryQuality.charactersScore;
      scores["voice"] = report.literaryQuality.voiceScore;
      scores["pacing"] = report.literaryQuality.pacingScore;
      scores["theme"] = report.literaryQuality.themeScore;
      strengths.push(...report.literaryQuality.strengths);
      improvements.push(...report.literaryQuality.improvements);
    }
    const avgScore = Object.values(scores).length > 0 ? Object.values(scores).reduce((a, b) => a + b, 0) / Object.values(scores).length : 3;
    let recommendation;
    if (avgScore >= 4.5) {
      recommendation = "ready-for-submission";
    } else if (avgScore >= 4) {
      recommendation = "copyediting";
    } else if (avgScore >= 3.5) {
      recommendation = "line-editing";
    } else if (avgScore >= 3) {
      recommendation = "developmental-editing";
    } else {
      recommendation = "structural-revision";
    }
    return {
      strengths,
      improvements: improvements.sort((a, b) => {
        const priority = { high: 0, medium: 1, low: 2 };
        return priority[a.priority] - priority[b.priority];
      }),
      scores,
      recommendation,
      notes: `Analysis based on ${structure.totalWords.toLocaleString()} words across ${structure.chapters.length} chapters.`
    };
  }
  readabilityToScore(fleschKincaid) {
    if (fleschKincaid >= 6 && fleschKincaid <= 10)
      return 5;
    if (fleschKincaid >= 4 && fleschKincaid <= 12)
      return 4;
    if (fleschKincaid >= 2 && fleschKincaid <= 14)
      return 3;
    return 2;
  }
  createProgressTracker(onProgress) {
    return {
      update: (phase, currentStep, totalSteps, message) => {
        if (onProgress) {
          onProgress({
            phase,
            currentStep,
            totalSteps,
            message,
            percentage: Math.round(currentStep / totalSteps * 100)
          });
        }
      }
    };
  }
};

// src/reports/report-generator.ts
var ReportGenerator = class {
  constructor(settings) {
    this.settings = settings;
  }
  generate(report) {
    const sections = [];
    sections.push(this.generateHeader(report));
    sections.push(this.generateExecutiveSummary(report.executiveSummary, report.metadata));
    if (report.readability) {
      sections.push(this.generateReadabilitySection(report.readability));
    }
    if (report.cadence) {
      sections.push(this.generateCadenceSection(report.cadence));
    }
    if (report.aiDetection) {
      sections.push(this.generateAIDetectionSection(report.aiDetection));
    }
    if (report.structure) {
      sections.push(this.generateStructureSection(report.structure));
    }
    if (report.literaryQuality) {
      sections.push(this.generateLiteraryQualitySection(report.literaryQuality));
    }
    sections.push(this.generateFooter(report));
    return sections.join("\n\n---\n\n");
  }
  generateHeader(report) {
    return `---
title: "An\xE1lise: ${report.metadata.manuscriptTitle}"
date: ${report.metadata.analysisDate}
plugin: SmartWriter Analyzer v${report.metadata.version}
persona: ${report.metadata.persona}
---

# \u{1F4CA} Relat\xF3rio de An\xE1lise

**Manuscrito:** ${report.metadata.manuscriptTitle}
**Palavras:** ${report.metadata.wordCount.toLocaleString()}
**Cap\xEDtulos:** ${report.metadata.chapterCount}
**Data da An\xE1lise:** ${new Date(report.metadata.analysisDate).toLocaleDateString("pt-BR")}`;
  }
  generateExecutiveSummary(summary, metadata) {
    const recommendationLabels = {
      "structural-revision": "\u{1F534} Revis\xE3o Estrutural",
      "developmental-editing": "\u{1F7E0} Edi\xE7\xE3o de Desenvolvimento",
      "line-editing": "\u{1F7E1} Edi\xE7\xE3o de Linha",
      "copyediting": "\u{1F7E2} Copyediting",
      "ready-for-submission": "\u2705 Pronto para Submiss\xE3o"
    };
    let content = `## \u{1F4CB} Sum\xE1rio Executivo

### Recomenda\xE7\xE3o
${recommendationLabels[summary.recommendation]}

### Scores
| Dimens\xE3o | Score |
|----------|-------|
`;
    for (const [key, value] of Object.entries(summary.scores)) {
      const label = this.formatScoreLabel(key);
      const stars = this.getStars(value);
      content += `| ${label} | ${stars} (${value}/5) |
`;
    }
    if (summary.strengths.length > 0) {
      content += `
### \u2705 Pontos Fortes
`;
      for (const strength of summary.strengths) {
        content += `- ${strength}
`;
      }
    }
    if (summary.improvements.length > 0) {
      content += `
### \u{1F527} \xC1reas de Melhoria
`;
      const byPriority = {
        high: summary.improvements.filter((i) => i.priority === "high"),
        medium: summary.improvements.filter((i) => i.priority === "medium"),
        low: summary.improvements.filter((i) => i.priority === "low")
      };
      if (byPriority.high.length > 0) {
        content += `
#### \u{1F534} Alta Prioridade
`;
        for (const imp of byPriority.high) {
          content += `- **${imp.area}**: ${imp.description}
  - *Sugest\xE3o:* ${imp.suggestion}
`;
        }
      }
      if (byPriority.medium.length > 0) {
        content += `
#### \u{1F7E1} M\xE9dia Prioridade
`;
        for (const imp of byPriority.medium) {
          content += `- **${imp.area}**: ${imp.description}
  - *Sugest\xE3o:* ${imp.suggestion}
`;
        }
      }
      if (byPriority.low.length > 0) {
        content += `
#### \u{1F7E2} Baixa Prioridade
`;
        for (const imp of byPriority.low) {
          content += `- **${imp.area}**: ${imp.description}
  - *Sugest\xE3o:* ${imp.suggestion}
`;
        }
      }
    }
    if (summary.notes) {
      content += `
> ${summary.notes}`;
    }
    return content;
  }
  generateReadabilitySection(metrics) {
    const interpretation = this.interpretReadability(metrics.fleschKincaid);
    return `## \u{1F4D6} Legibilidade

### M\xE9tricas

| \xCDndice | Valor | Interpreta\xE7\xE3o |
|--------|-------|---------------|
| Flesch-Kincaid | ${metrics.fleschKincaid.toFixed(1)} | ${interpretation.level} |
| SMOG | ${metrics.smog.toFixed(1)} | ${metrics.smog.toFixed(0)} anos de educa\xE7\xE3o |
| Gunning Fog | ${metrics.gunningFog.toFixed(1)} | ${this.interpretFog(metrics.gunningFog)} |
| ARI | ${metrics.ari.toFixed(1)} | N\xEDvel ${Math.round(metrics.ari)} |

### Estat\xEDsticas

| M\xE9trica | Valor |
|---------|-------|
| M\xE9dia de palavras por frase | ${metrics.avgSentenceLength.toFixed(1)} |
| M\xE9dia de palavras por par\xE1grafo | ${metrics.avgParagraphLength.toFixed(1)} |
| M\xE9dia de caracteres por palavra | ${metrics.avgWordLength.toFixed(1)} |
| Raz\xE3o de palavras complexas | ${(metrics.complexWordRatio * 100).toFixed(1)}% |

### An\xE1lise
${interpretation.audience}. ${interpretation.suggestion}`;
  }
  generateCadenceSection(metrics) {
    const rhythmLabels = {
      uniform: "\u26A0\uFE0F Uniforme (mon\xF3tono)",
      varied: "\u2705 Variado (natural)",
      chaotic: "\u26A0\uFE0F Ca\xF3tico (irregular)"
    };
    let content = `## \u{1F3B5} Cad\xEAncia e Ritmo

### M\xE9tricas Globais

| M\xE9trica | Valor | Avalia\xE7\xE3o |
|---------|-------|-----------|
| Burstiness | ${(metrics.burstiness * 100).toFixed(1)}% | ${metrics.burstiness > 0.2 ? "\u2705 Bom" : "\u26A0\uFE0F Baixo"} |
| Vari\xE2ncia de Frases | ${metrics.sentenceLengthVariance.toFixed(1)} | \u2014 |
| Vari\xE2ncia de Par\xE1grafos | ${metrics.paragraphLengthVariance.toFixed(1)} | \u2014 |
| Padr\xE3o R\xEDtmico | \u2014 | ${rhythmLabels[metrics.rhythmPattern]} |

### Pacing por Cap\xEDtulo

| Cap\xEDtulo | M\xE9dia Palavras/Frase | Burstiness | Ritmo |
|----------|---------------------|------------|-------|
`;
    for (const chapter of metrics.pacingByChapter.slice(0, 20)) {
      const paceEmoji = chapter.paceCategory === "fast" ? "\u{1F3C3}" : chapter.paceCategory === "slow" ? "\u{1F422}" : "\u{1F6B6}";
      content += `| Cap. ${chapter.chapter} | ${chapter.avgSentenceLength.toFixed(1)} | ${(chapter.burstiness * 100).toFixed(0)}% | ${paceEmoji} ${chapter.paceCategory} |
`;
    }
    if (metrics.pacingByChapter.length > 20) {
      content += `
*... e mais ${metrics.pacingByChapter.length - 20} cap\xEDtulos*`;
    }
    return content;
  }
  generateAIDetectionSection(result) {
    const classificationLabels = {
      "authentic": "\u2705 Aut\xEAntico",
      "assisted": "\u{1F535} Assistido por IA",
      "hybrid": "\u{1F7E1} H\xEDbrido",
      "predominantly-ai": "\u{1F7E0} Predominantemente IA",
      "ai-generated": "\u{1F534} Gerado por IA"
    };
    let content = `## \u{1F916} An\xE1lise de Autenticidade (DETECT-AI)

### \xCDndice de Uso de LLM (IUL)

\`\`\`
IUL: ${result.iul}%
Classifica\xE7\xE3o: ${classificationLabels[result.classification]}

[${this.generateIULBar(result.iul)}] ${result.iul}%
  0%        35%        60%        85%       100%
  Aut\xEAntico | H\xEDbrido  | Predom.IA | Gerado IA
\`\`\`

### Escala de Interpreta\xE7\xE3o

| Faixa | Classifica\xE7\xE3o | Descri\xE7\xE3o |
|-------|---------------|-----------|
| 0-15% | Aut\xEAntico | Texto predominantemente humano |
| 16-35% | Assistido | Poss\xEDvel uso de ferramentas de IA como apoio |
| 36-60% | H\xEDbrido | Mistura significativa de conte\xFAdo humano e IA |
| 61-85% | Predom. IA | Maior parte gerada por IA |
| 86-100% | Gerado por IA | Quase totalmente gerado por IA |

`;
    if (result.artifacts.length > 0) {
      content += `### Artefatos Detectados

| C\xF3digo | Categoria | Marcador | Peso | Inst\xE2ncias |
|--------|-----------|----------|------|------------|
`;
      for (const artifact of result.artifacts) {
        const weightEmoji = artifact.weight === "high" ? "\u{1F534}" : artifact.weight === "medium" ? "\u{1F7E1}" : "\u{1F7E2}";
        content += `| ${artifact.code} | ${artifact.category} | ${artifact.marker} | ${weightEmoji} | ${artifact.instances.length} |
`;
      }
    }
    if (result.sampleAnalysis.length > 0) {
      content += `
### An\xE1lise por Amostra

| Amostra | Localiza\xE7\xE3o | Palavras | IUL Local | Artefatos |
|---------|-------------|----------|-----------|-----------|
`;
      for (const sample of result.sampleAnalysis) {
        content += `| ${sample.sampleIndex + 1} | ${sample.location} | ${sample.wordCount} | ${sample.localIul}% | ${sample.artifactsFound.join(", ") || "\u2014"} |
`;
      }
    }
    return content;
  }
  generateStructureSection(structure) {
    let content = `## \u{1F3D7}\uFE0F Estrutura Narrativa

### Propor\xE7\xE3o dos Atos

| Ato | Propor\xE7\xE3o | Ideal | Status |
|-----|-----------|-------|--------|
| Ato 1 (Setup) | ${structure.acts.act1Percentage}% | 25% | ${this.getProportionStatus(structure.acts.act1Percentage, 25)} |
| Ato 2 (Confronto) | ${structure.acts.act2Percentage}% | 50% | ${this.getProportionStatus(structure.acts.act2Percentage, 50)} |
| Ato 3 (Resolu\xE7\xE3o) | ${structure.acts.act3Percentage}% | 25% | ${this.getProportionStatus(structure.acts.act3Percentage, 25)} |

**Score de Balanceamento:** ${this.getStars(structure.acts.balanceScore)} (${structure.acts.balanceScore}/5)

### Save the Cat Beats

| Beat | Presente | Posi\xE7\xE3o | Cap\xEDtulo | Efic\xE1cia |
|------|----------|---------|----------|----------|
`;
    for (const beat of structure.beats) {
      const presentEmoji = beat.present ? "\u2705" : "\u274C";
      content += `| ${beat.name} | ${presentEmoji} | ${beat.position}% | Cap. ${beat.chapter} | ${this.getStars(beat.efficacy)} |
`;
    }
    content += `
### Turning Points

| Ponto | Cap\xEDtulo | Posi\xE7\xE3o | For\xE7a |
|-------|----------|---------|-------|
`;
    for (const tp of structure.turningPoints) {
      content += `| ${tp.name} | Cap. ${tp.chapter} | ${tp.position}% | ${this.getStars(tp.strength)} |
`;
    }
    content += `
### Causalidade
**Score:** ${this.getStars(structure.causalityScore)} (${structure.causalityScore}/5)

> A causalidade mede o qu\xE3o bem os eventos da hist\xF3ria seguem uma l\xF3gica de causa e efeito.`;
    return content;
  }
  generateLiteraryQualitySection(quality) {
    let content = `## \u{1F4DA} Qualidade Liter\xE1ria

> *An\xE1lise realizada pela persona Helena Vasconcelos*

### Sinopse Estrutural

${quality.synopsis}

### Scores por Dimens\xE3o

| Dimens\xE3o | Score | Avalia\xE7\xE3o |
|----------|-------|-----------|
| Estrutura | ${this.getStars(quality.structureScore)} | ${quality.structureScore}/5 |
| Coer\xEAncia | ${this.getStars(quality.coherenceScore)} | ${quality.coherenceScore}/5 |
| Personagens | ${this.getStars(quality.charactersScore)} | ${quality.charactersScore}/5 |
| Voz e Estilo | ${this.getStars(quality.voiceScore)} | ${quality.voiceScore}/5 |
| Pacing | ${this.getStars(quality.pacingScore)} | ${quality.pacingScore}/5 |
| Worldbuilding | ${this.getStars(quality.worldbuildingScore)} | ${quality.worldbuildingScore}/5 |
| Tema | ${this.getStars(quality.themeScore)} | ${quality.themeScore}/5 |
| Conformidade de G\xEAnero | ${this.getStars(quality.genreConformityScore)} | ${quality.genreConformityScore}/5 |
| **OVERALL** | **${this.getStars(quality.overallScore)}** | **${quality.overallScore}/5** |

`;
    if (quality.strengths.length > 0) {
      content += `### Pontos Fortes Identificados
`;
      for (const strength of quality.strengths) {
        content += `- ${strength}
`;
      }
    }
    if (quality.improvements.length > 0) {
      content += `
### Recomenda\xE7\xF5es de Melhoria
`;
      for (const imp of quality.improvements) {
        const priorityEmoji = imp.priority === "high" ? "\u{1F534}" : imp.priority === "medium" ? "\u{1F7E1}" : "\u{1F7E2}";
        content += `
#### ${priorityEmoji} ${imp.area}
`;
        content += `${imp.description}

`;
        content += `> **Sugest\xE3o:** ${imp.suggestion}
`;
      }
    }
    return content;
  }
  generateFooter(report) {
    return `## \u{1F4DD} Notas

Este relat\xF3rio foi gerado automaticamente pelo **SmartWriter Analyzer** v${report.metadata.version}.

- **Persona:** ${report.metadata.persona === "helena-vasconcelos" ? "Helena Vasconcelos (Analista Liter\xE1ria T\xE9cnica)" : "An\xE1lise Computacional"}
- **Metodologia:** Combina\xE7\xE3o de an\xE1lise computacional e assist\xEAncia de LLM
- **Limita\xE7\xF5es:** Este relat\xF3rio \xE9 uma ferramenta de apoio \xE0 edi\xE7\xE3o e n\xE3o substitui a avalia\xE7\xE3o humana qualificada.

---

*Gerado em ${new Date(report.metadata.analysisDate).toLocaleString("pt-BR")}*`;
  }
  // Helper methods
  getStars(score) {
    const fullStars = Math.floor(score);
    const hasHalf = score - fullStars >= 0.5;
    let stars = "\u2605".repeat(fullStars);
    if (hasHalf)
      stars += "\xBD";
    stars += "\u2606".repeat(5 - Math.ceil(score));
    return stars;
  }
  formatScoreLabel(key) {
    const labels = {
      readability: "Legibilidade",
      cadence: "Cad\xEAncia",
      authenticity: "Autenticidade",
      structure: "Estrutura",
      coherence: "Coer\xEAncia",
      characters: "Personagens",
      voice: "Voz/Estilo",
      pacing: "Pacing",
      worldbuilding: "Worldbuilding",
      theme: "Tema"
    };
    return labels[key] || key;
  }
  interpretReadability(fk) {
    if (fk <= 6) {
      return {
        level: "Muito F\xE1cil",
        audience: "Apropriado para leitores jovens ou iniciantes",
        suggestion: "O texto \xE9 muito acess\xEDvel."
      };
    } else if (fk <= 8) {
      return {
        level: "F\xE1cil",
        audience: "Bom para p\xFAblico geral e fic\xE7\xE3o comercial",
        suggestion: "N\xEDvel ideal para fic\xE7\xE3o de massa."
      };
    } else if (fk <= 10) {
      return {
        level: "Moderado",
        audience: "Adequado para fic\xE7\xE3o adulta e n\xE3o-fic\xE7\xE3o acess\xEDvel",
        suggestion: "Equil\xEDbrio entre acessibilidade e profundidade."
      };
    } else if (fk <= 12) {
      return {
        level: "Moderadamente Dif\xEDcil",
        audience: "Apropriado para fic\xE7\xE3o liter\xE1ria",
        suggestion: "Considere se o p\xFAblico-alvo comporta esta complexidade."
      };
    } else if (fk <= 14) {
      return {
        level: "Dif\xEDcil",
        audience: "N\xEDvel universit\xE1rio",
        suggestion: "Pode ser complexo demais para p\xFAblicos amplos."
      };
    } else {
      return {
        level: "Muito Dif\xEDcil",
        audience: "N\xEDvel acad\xEAmico/especializado",
        suggestion: "Simplifica\xE7\xE3o recomendada para p\xFAblicos gerais."
      };
    }
  }
  interpretFog(fog) {
    if (fog <= 8)
      return "F\xE1cil";
    if (fog <= 10)
      return "M\xE9dio";
    if (fog <= 12)
      return "Dif\xEDcil";
    return "Muito Dif\xEDcil";
  }
  generateIULBar(iul) {
    const totalWidth = 40;
    const filled = Math.round(iul / 100 * totalWidth);
    return "\u2588".repeat(filled) + "\u2591".repeat(totalWidth - filled);
  }
  getProportionStatus(actual, ideal) {
    const diff = Math.abs(actual - ideal);
    if (diff <= 5)
      return "\u2705";
    if (diff <= 10)
      return "\u26A0\uFE0F";
    return "\u274C";
  }
};

// src/ui/analysis-modal.ts
var import_obsidian2 = require("obsidian");
var AnalysisModal = class extends import_obsidian2.Modal {
  constructor(app, plugin, file) {
    super(app);
    this.selectedReports = /* @__PURE__ */ new Set(["readability", "cadence"]);
    this.isAnalyzing = false;
    this.progressEl = null;
    this.progressBarEl = null;
    this.progressTextEl = null;
    this.analyzeButton = null;
    this.plugin = plugin;
    this.file = file;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("swa-modal");
    contentEl.createEl("h2", { text: "SmartWriter Analyzer", cls: "swa-modal-title" });
    const fileInfo = contentEl.createDiv({ cls: "swa-file-info" });
    fileInfo.createEl("p", { text: `Arquivo: ${this.file.basename}` });
    this.app.vault.read(this.file).then((content) => {
      const wordCount = content.split(/\s+/).filter((w) => w.length > 0).length;
      fileInfo.createEl("p", {
        text: `Palavras: ~${wordCount.toLocaleString()}`,
        cls: "swa-word-count"
      });
      if (wordCount > 1e5) {
        fileInfo.createEl("p", {
          text: "\u26A0\uFE0F Manuscrito grande - an\xE1lise pode demorar alguns minutos",
          cls: "swa-warning"
        });
      }
    });
    contentEl.createEl("h3", { text: "Selecione as an\xE1lises" });
    const reportOptions = contentEl.createDiv({ cls: "swa-report-options" });
    this.createReportOption(
      reportOptions,
      "readability",
      "Legibilidade",
      "Flesch-Kincaid, SMOG, Gunning Fog, ARI"
    );
    this.createReportOption(
      reportOptions,
      "cadence",
      "Cad\xEAncia",
      "Burstiness, ritmo, varia\xE7\xE3o de frases"
    );
    this.createReportOption(
      reportOptions,
      "ai-detection",
      "Detec\xE7\xE3o de IA",
      "Protocolo DETECT-AI, IUL (\xCDndice de Uso de LLM)"
    );
    this.createReportOption(
      reportOptions,
      "structure",
      "Estrutura Narrativa",
      "Save the Cat beats, propor\xE7\xE3o de atos, turning points"
    );
    this.createReportOption(
      reportOptions,
      "literary-quality",
      "Qualidade Liter\xE1ria (Helena)",
      "An\xE1lise completa: personagens, voz, tema, worldbuilding"
    );
    this.progressEl = contentEl.createDiv({ cls: "swa-progress-container" });
    this.progressEl.style.display = "none";
    const progressBar = this.progressEl.createDiv({ cls: "swa-progress-bar" });
    this.progressBarEl = progressBar.createDiv({ cls: "swa-progress-fill" });
    this.progressBarEl.style.width = "0%";
    this.progressTextEl = this.progressEl.createDiv({ cls: "swa-progress-text" });
    this.progressTextEl.setText("Preparando an\xE1lise...");
    const buttonContainer = contentEl.createDiv({ cls: "swa-button-container" });
    buttonContainer.style.display = "flex";
    buttonContainer.style.gap = "10px";
    buttonContainer.style.marginTop = "20px";
    new import_obsidian2.Setting(buttonContainer).addButton((btn) => {
      this.analyzeButton = btn;
      btn.setButtonText("Analisar").setCta().onClick(() => this.runAnalysis());
    }).addButton(
      (btn) => btn.setButtonText("Cancelar").onClick(() => this.close())
    );
  }
  createReportOption(container, type, label, description) {
    const option = container.createDiv({ cls: "swa-report-option" });
    const checkbox = option.createEl("input", {
      type: "checkbox",
      attr: { id: `swa-${type}` }
    });
    if (this.selectedReports.has(type)) {
      checkbox.checked = true;
      option.addClass("selected");
    }
    checkbox.addEventListener("change", () => {
      if (checkbox.checked) {
        this.selectedReports.add(type);
        option.addClass("selected");
      } else {
        this.selectedReports.delete(type);
        option.removeClass("selected");
      }
    });
    const labelContainer = option.createDiv({ cls: "swa-option-label" });
    labelContainer.createEl("label", {
      text: label,
      attr: { for: `swa-${type}` },
      cls: "swa-option-title"
    });
    labelContainer.createEl("small", {
      text: description,
      cls: "swa-option-desc"
    });
    option.addEventListener("click", (e) => {
      if (e.target !== checkbox) {
        checkbox.checked = !checkbox.checked;
        checkbox.dispatchEvent(new Event("change"));
      }
    });
  }
  async runAnalysis() {
    var _a, _b, _c, _d;
    if (this.isAnalyzing)
      return;
    if (this.selectedReports.size === 0) {
      new import_obsidian2.Notice("Selecione pelo menos uma an\xE1lise");
      return;
    }
    this.isAnalyzing = true;
    (_a = this.analyzeButton) == null ? void 0 : _a.setDisabled(true);
    (_b = this.analyzeButton) == null ? void 0 : _b.setButtonText("Analisando...");
    if (this.progressEl) {
      this.progressEl.style.display = "block";
    }
    try {
      const reportPath = await this.plugin.runFullAnalysis(
        this.file,
        Array.from(this.selectedReports),
        (progress) => this.updateProgress(progress)
      );
      new import_obsidian2.Notice("An\xE1lise conclu\xEDda! Relat\xF3rio salvo.");
      const reportFile = this.app.vault.getAbstractFileByPath(reportPath);
      if (reportFile instanceof import_obsidian2.TFile) {
        await this.app.workspace.getLeaf().openFile(reportFile);
      }
      this.close();
    } catch (error) {
      console.error("Analysis failed:", error);
      new import_obsidian2.Notice(`Erro na an\xE1lise: ${error.message}`);
      this.isAnalyzing = false;
      (_c = this.analyzeButton) == null ? void 0 : _c.setDisabled(false);
      (_d = this.analyzeButton) == null ? void 0 : _d.setButtonText("Tentar Novamente");
      if (this.progressTextEl) {
        this.progressTextEl.setText(`Erro: ${error.message}`);
        this.progressTextEl.style.color = "var(--text-error)";
      }
    }
  }
  updateProgress(progress) {
    if (this.progressBarEl) {
      this.progressBarEl.style.width = `${progress.percentage}%`;
    }
    if (this.progressTextEl) {
      this.progressTextEl.setText(progress.message);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/main.ts
var SmartWriterPlugin = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    this.cacheManager = new CacheManager(this);
    this.llmService = new LLMService(this.settings);
    this.orchestrator = new AnalysisOrchestrator(
      this.settings,
      this.llmService,
      this.cacheManager
    );
    this.addRibbonIcon("book-open", "SmartWriter Analyzer", () => {
      this.openAnalysisModal();
    });
    this.addCommand({
      id: "analyze-manuscript",
      name: "Analyze manuscript",
      checkCallback: (checking) => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile && activeFile.extension === "md") {
          if (!checking) {
            this.openAnalysisModal();
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "quick-readability",
      name: "Quick readability check",
      checkCallback: (checking) => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile && activeFile.extension === "md") {
          if (!checking) {
            this.runQuickAnalysis(["readability"]);
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "detect-ai",
      name: "Detect AI artifacts",
      checkCallback: (checking) => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile && activeFile.extension === "md") {
          if (!checking) {
            this.runQuickAnalysis(["ai-detection"]);
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "clear-cache",
      name: "Clear analysis cache",
      callback: () => {
        this.cacheManager.clearAll();
        new import_obsidian3.Notice("SmartWriter: Cache cleared");
      }
    });
    this.addSettingTab(new SmartWriterSettingTab(this.app, this));
    this.addStatusBarItem().setText("SmartWriter Ready");
    console.log("SmartWriter Analyzer loaded");
  }
  onunload() {
    console.log("SmartWriter Analyzer unloaded");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    var _a;
    await this.saveData(this.settings);
    (_a = this.llmService) == null ? void 0 : _a.updateSettings(this.settings);
  }
  openAnalysisModal() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian3.Notice("No file open");
      return;
    }
    new AnalysisModal(this.app, this, activeFile).open();
  }
  async runQuickAnalysis(reportTypes) {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian3.Notice("No file open");
      return;
    }
    const statusBar = this.addStatusBarItem();
    statusBar.setText("SmartWriter: Analyzing...");
    try {
      const content = await this.app.vault.read(activeFile);
      const report = await this.orchestrator.analyze(
        {
          manuscriptPath: activeFile.path,
          manuscriptContent: content,
          wordCount: this.countWords(content),
          selectedReports: reportTypes
        },
        (progress) => {
          statusBar.setText(`SmartWriter: ${progress.message} (${progress.percentage}%)`);
        }
      );
      const generator = new ReportGenerator(this.settings);
      const reportContent = generator.generate(report);
      await this.saveReport(activeFile.basename, reportContent);
      statusBar.setText("SmartWriter: Complete");
      new import_obsidian3.Notice("Analysis complete! Report saved.");
    } catch (error) {
      console.error("Analysis failed:", error);
      statusBar.setText("SmartWriter: Error");
      new import_obsidian3.Notice(`Analysis failed: ${error.message}`);
    }
  }
  async runFullAnalysis(file, reportTypes, progressCallback) {
    const content = await this.app.vault.read(file);
    const report = await this.orchestrator.analyze(
      {
        manuscriptPath: file.path,
        manuscriptContent: content,
        wordCount: this.countWords(content),
        selectedReports: reportTypes,
        persona: "helena-vasconcelos"
      },
      progressCallback
    );
    const generator = new ReportGenerator(this.settings);
    const reportContent = generator.generate(report);
    const reportPath = await this.saveReport(file.basename, reportContent);
    return reportPath;
  }
  async saveReport(manuscriptName, content) {
    const folder = this.settings.reportOutputFolder;
    const timestamp = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
    const fileName = `${manuscriptName}_Analysis_${timestamp}.md`;
    const path = `${folder}/${fileName}`;
    if (!await this.app.vault.adapter.exists(folder)) {
      await this.app.vault.createFolder(folder);
    }
    const existingFile = this.app.vault.getAbstractFileByPath(path);
    if (existingFile instanceof import_obsidian3.TFile) {
      await this.app.vault.modify(existingFile, content);
    } else {
      await this.app.vault.create(path, content);
    }
    return path;
  }
  countWords(text) {
    return text.split(/\s+/).filter((word) => word.length > 0).length;
  }
};
var SmartWriterSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "LLM configuration" });
    new import_obsidian3.Setting(containerEl).setName("Provider").setDesc("Select the LLM provider for analysis").addDropdown((dropdown) => dropdown.addOption("ollama", "Ollama (Local)").addOption("claude", "Claude (Anthropic)").addOption("openai", "OpenAI").setValue(this.plugin.settings.llmProvider).onChange(async (value) => {
      this.plugin.settings.llmProvider = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.llmProvider === "ollama") {
      new import_obsidian3.Setting(containerEl).setName("Ollama endpoint").setDesc("URL of your Ollama server").addText((text) => text.setPlaceholder("http://localhost:11434").setValue(this.plugin.settings.ollamaEndpoint).onChange(async (value) => {
        this.plugin.settings.ollamaEndpoint = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian3.Setting(containerEl).setName("Model").setDesc("Ollama model to use (e.g., llama3.1, mistral)").addText((text) => text.setPlaceholder("llama3.1").setValue(this.plugin.settings.ollamaModel).onChange(async (value) => {
        this.plugin.settings.ollamaModel = value;
        await this.plugin.saveSettings();
      }));
    }
    if (this.plugin.settings.llmProvider === "claude") {
      new import_obsidian3.Setting(containerEl).setName("API key").setDesc("Your Anthropic API key").addText((text) => text.setPlaceholder("sk-ant-...").setValue(this.plugin.settings.claudeApiKey).onChange(async (value) => {
        this.plugin.settings.claudeApiKey = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian3.Setting(containerEl).setName("Model").setDesc("Claude model to use").addDropdown((dropdown) => dropdown.addOption("claude-sonnet-4-20250514", "Claude Sonnet 4").addOption("claude-3-5-sonnet-20241022", "Claude 3.5 Sonnet").addOption("claude-3-opus-20240229", "Claude 3 Opus").setValue(this.plugin.settings.claudeModel).onChange(async (value) => {
        this.plugin.settings.claudeModel = value;
        await this.plugin.saveSettings();
      }));
    }
    if (this.plugin.settings.llmProvider === "openai") {
      new import_obsidian3.Setting(containerEl).setName("API key").setDesc("Your OpenAI API key").addText((text) => text.setPlaceholder("sk-...").setValue(this.plugin.settings.openaiApiKey).onChange(async (value) => {
        this.plugin.settings.openaiApiKey = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian3.Setting(containerEl).setName("Model").setDesc("OpenAI model to use").addDropdown((dropdown) => dropdown.addOption("gpt-4o", "GPT-4o").addOption("gpt-4-turbo", "GPT-4 Turbo").addOption("gpt-4", "GPT-4").setValue(this.plugin.settings.openaiModel).onChange(async (value) => {
        this.plugin.settings.openaiModel = value;
        await this.plugin.saveSettings();
      }));
    }
    containerEl.createEl("h2", { text: "Analysis configuration" });
    new import_obsidian3.Setting(containerEl).setName("Chunk size").setDesc("Words per analysis chunk (larger = more context, slower)").addSlider((slider) => slider.setLimits(5e3, 5e4, 1e3).setValue(this.plugin.settings.chunkSize).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.chunkSize = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Cache duration").setDesc("Days to keep cached analysis results").addSlider((slider) => slider.setLimits(1, 90, 1).setValue(this.plugin.settings.cacheDurationDays).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.cacheDurationDays = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Language").setDesc("Primary language for analysis").addDropdown((dropdown) => dropdown.addOption("pt-BR", "Portugu\xEAs (Brasil)").addOption("en-US", "English (US)").addOption("es-ES", "Espa\xF1ol").setValue(this.plugin.settings.language).onChange(async (value) => {
      this.plugin.settings.language = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", { text: "Features" });
    new import_obsidian3.Setting(containerEl).setName("AI detection").setDesc("Enable DETECT-AI protocol for artifact detection").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableAIDetection).onChange(async (value) => {
      this.plugin.settings.enableAIDetection = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("ABNT formatting").setDesc("Enable ABNT academic formatting option").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableABNTFormatting).onChange(async (value) => {
      this.plugin.settings.enableABNTFormatting = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Auto-save reports").setDesc("Automatically save generated reports").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoSaveReports).onChange(async (value) => {
      this.plugin.settings.autoSaveReports = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Report folder").setDesc("Folder for saved reports").addText((text) => text.setPlaceholder("SmartWriter Reports").setValue(this.plugin.settings.reportOutputFolder).onChange(async (value) => {
      this.plugin.settings.reportOutputFolder = value;
      await this.plugin.saveSettings();
    }));
  }
};
